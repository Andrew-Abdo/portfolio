diff --git a/lib/SuiveurLigneCytron_LSS05.cpp b/lib/SuiveurLigneCytron_LSS05.cpp
index 2ef38aa..068fa52 100644
--- a/lib/SuiveurLigneCytron_LSS05.cpp
+++ b/lib/SuiveurLigneCytron_LSS05.cpp
@@ -1,27 +1,29 @@
 #include "SuiveurLigneCytron_LSS05.h"
 #include "commun.h"
-#include "debug.h"
+// #include "debug.h"
 
-SuiveurLigneCytron_LSS05::SuiveurLigneCytron_LSS05(){
+SuiveurLigneCytron_LSS05::SuiveurLigneCytron_LSS05()
+{
     // PINA2 à PINA6 en entrée
     DDRA &= ~(1 << PA2) & ~(1 << PA3) & ~(1 << PA4) & ~(1 << PA5) & ~(1 << PA6);
-    
 }
-void SuiveurLigneCytron_LSS05::detecterLigne(bool& estLigne){
-    
+
+void SuiveurLigneCytron_LSS05::detecterLigne(bool& estLigne)
+{
     if(LIGNE){
-        // DEBUG_PRINT("CEST UNE LIGNE\n");
+        
         estLigne = true;
-    }else{
-        // DEBUG_PRINT("CEST PAS UNE LIGNE\n");
+    }
+    else{
+        
         estLigne = false;
     }
 }
-void SuiveurLigneCytron_LSS05::detecterAngleDroit(bool& angleDroitAtteint){
 
+void SuiveurLigneCytron_LSS05::detecterAngleDroit(bool& angleDroitAtteint)
+{
         //Si le robot detecte un angle droit ou un angle gauche
         if(ANGLE_DROIT_DROITE || ANGLE_DROIT_GAUCHE){
-            
             angleDroitAtteint = true;
         }
         else{
@@ -29,104 +31,120 @@ void SuiveurLigneCytron_LSS05::detecterAngleDroit(bool& angleDroitAtteint){
         }
 }
 
-void SuiveurLigneCytron_LSS05::detecterCoupure(bool& estCoupure){
-    
-    if(COUPURE){
+void SuiveurLigneCytron_LSS05::detecterCoupure(bool& estCoupure)
+{
+    if(COUPURE)
+    {
         //Debounce coupure
-        commun::delai_ms(400);
+        commun::delai_ms(50);
         if(COUPURE){
-            DEBUG_PRINT("COUPURE OK\n");
-        estCoupure = true;
+            
+            estCoupure = true;
         }
-    }else{
-            DEBUG_PRINT("COUPURE NON DETECTER\n");
-
+    }
+    else{ 
         estCoupure = false;
     }
 }
 
-void SuiveurLigneCytron_LSS05::detecterLigneCentre(bool& estLigneCentre){
-    
+void SuiveurLigneCytron_LSS05::detecterLigneCentre(bool& estLigneCentre)
+{
     if(LIGNE_CENTRE){
-        DEBUG_PRINT("CEST UNE LIGNE CENTRE\n");
-        estLigneCentre = true;
-    }else{
-        DEBUG_PRINT("CEST PAS UNE LIGNE CENTRE\n");
+
+        commun::delai_ms(50);
+        
+        if(LIGNE_CENTRE){
+
+            estLigneCentre = true;
+        
+        }
+    }
+    else{
         estLigneCentre = false;
     }
 }
 
-void SuiveurLigneCytron_LSS05::detecterCoupureCentre(bool& estCoupureCentre){
-    
+void SuiveurLigneCytron_LSS05::detecterCoupureCentre(bool& estCoupureCentre)
+{
     if(!LIGNE_CENTRE){
+        
         //debounche pour sassurer que cest reellement une coupure
-        commun::delai_ms(100);
+        commun::delai_ms(300);
+        
         if(!LIGNE_CENTRE){
-        DEBUG_PRINT("CEST UNE COUPURE CENTRE\n");
-        estCoupureCentre = true;
+        
+            estCoupureCentre = true;
+        
         }
-    }else{
-        DEBUG_PRINT("CEST PAS UNE COUPURE CENTRE\n");
+    }
+    else{
+
         estCoupureCentre = false;
+
     }
 }
 
-void SuiveurLigneCytron_LSS05::corrigerPWM(const uint8_t vitesse){
-    
-
+void SuiveurLigneCytron_LSS05::corrigerPWM(const uint8_t vitesse)
+{
     if(GAUCHE){
-        // DEBUG_PRINT("GAUCHE %d ; OCR1A %d ; OCR1B %d\n",PINA, OCR1A, OCR1B);
+        
         OCR1A = vitesse - REDRESSEMENT_MOYEN; // augmenter vitesse roueD
         OCR1B = vitesse + REDRESSEMENT_MOYEN;
+    
     }
     else if (UN_PEU_GAUCHE){
-        // DEBUG_PRINT("UN PEU GAUCHE %d ; OCR1A %d ; OCR1B %d\n",PINA, OCR1A, OCR1B);
+
         OCR1A = vitesse - REDRESSEMENT_BAS; // augmenter vitesse roueD
         OCR1B = vitesse + REDRESSEMENT_BAS;
+    
     }
     else if(TROP_A_GAUCHE){
-        // DEBUG_PRINT("TROP GAUCHE %d ; OCR1A %d ; OCR1B %d\n",PINA, OCR1A, OCR1B);
+
         OCR1A = vitesse - REDRESSEMENT_FORT; // augmenter vitesse roueD
         OCR1B = vitesse + REDRESSEMENT_FORT;
+    
     }
     else if(DROITE){
-        // DEBUG_PRINT("DROITE %d ; OCR1A %d ; OCR1B %d\n",PINA, OCR1A, OCR1B);
+
         OCR1A = vitesse + REDRESSEMENT_MOYEN; // diminuer vitesse roueD
         OCR1B = vitesse - REDRESSEMENT_MOYEN;
+    
     }
     else if(UN_PEU_DROITE){
-        // DEBUG_PRINT("UN PEU DROITE %d ; OCR1A %d ; OCR1B %d\n",PINA, OCR1A, OCR1B);
+
         OCR1A = vitesse + REDRESSEMENT_BAS; // diminuer vitesse roueD
         OCR1B = vitesse - REDRESSEMENT_BAS;
+    
     }
     else if(TROP_A_DROITE){
-        // DEBUG_PRINT("TROP DROITE %d ; OCR1A %d ; OCR1B %d\n",PINA, OCR1A, OCR1B);
+
         OCR1A = vitesse + REDRESSEMENT_FORT; // diminuer vitesse roueD
         OCR1B = vitesse - REDRESSEMENT_FORT;
+  
     }
     else if(CENTREE){
+
         OCR1A = vitesse; 
         OCR1B = vitesse; 
-        // DEBUG_PRINT("CENTREE %d ; OCR1A %d ; OCR1B %d\n",PINA, OCR1A, OCR1B);
+
     }
-    
 }
 
-void SuiveurLigneCytron_LSS05::corrigerPWMCouloir(const uint8_t vitesse){
+void SuiveurLigneCytron_LSS05::corrigerPWMCouloir(const uint8_t vitesse)
+{
+    // TODO Reajuster la correction du couloir, car le desequilibre des roues affecte grandement cette section.
+    // TODO suggestion ajouter des define pour les redressement de la roues gauche et droite independent.
+    
     //lorsque le robot touche le couloir de gauche
-    // DEBUG_PRINT("CORRECTION COULOIR\n");
     if(TROP_A_DROITE){
-
-        OCR1A = vitesse - REDRESSEEMNT_TRES_FORT; // diminuer vitesse roueD
-        OCR1B = vitesse + REDRESSEEMNT_TRES_FORT; //augmenter vitesse rougeG
-
+        
+        OCR1A = vitesse - REDRESSEMENT_MOYEN; //vitesse roueD
+        OCR1B = vitesse + REDRESSEMENT_BAS; //vitesse rougeG
     //lorsque le robot touche le couloir de droite
-    }else if(TROP_A_GAUCHE){
-        OCR1A = vitesse + REDRESSEEMNT_TRES_FORT; // diminuer vitesse roueD
-        OCR1B = vitesse - REDRESSEEMNT_TRES_FORT; //augmenter vitesse rougeG
-    }else{
-        OCR1A = vitesse;
-        OCR1B = vitesse;
     }
-}
-
+    else if(TROP_A_GAUCHE){
+        
+        OCR1A = vitesse + REDRESSEMENT_MOYEN; //  vitesse roueD
+        OCR1B = vitesse - REDRESSEMENT_BAS; // vitesse rougeG
+    }
+}
\ No newline at end of file
diff --git a/lib/SuiveurLigneCytron_LSS05.h b/lib/SuiveurLigneCytron_LSS05.h
index 7c62a17..13ca46f 100644
--- a/lib/SuiveurLigneCytron_LSS05.h
+++ b/lib/SuiveurLigneCytron_LSS05.h
@@ -1,8 +1,12 @@
 #ifndef SUIVEUR_LIGNE_CYTRON_LSS05_H
 #define SUIVEUR_LIGNE_CYTRON_LSS05_H
-
+//! PROBLEMES DES ROBOTS OBSERVE A DATE
+//! ROBOT n12 : Rouge droite plus rapide que roue gauche, cause une problematique dans l'ajustement du couloir
+//! ROBOT n17 : Rouge gauche legerement plus rapide que roue de droite, cause une problematique dans l'ajustement du couloir
+//* Cependant l'ajustement de ligne se fait sans probleme dans les deux robots, il faudra un meilleur ajustement du couloir.
 //Masque qui permettent de savoir quelle ajustement a la roue faire, dans le futur on peux ajouter
 // plus de cas possible
+
 #define TROP_A_GAUCHE   (PINA & (1 << PA6)) //0b01000000
 #define GAUCHE          (PINA & (1 << PA6)) && (PINA & (1 << PA5)) //0b01100000 
 #define UN_PEU_GAUCHE   PINA & (1 << PA5) //0b00100000 
@@ -19,35 +23,28 @@
 //Masque pour detecte une ligne ou une coupure
 #define LIGNE ((PINA & (1 << PA6)) || (PINA & (1 << PA5)) || (PINA & (1 << PA4)) || (PINA & (1 << PA3)) || (PINA & (1 << PA2)))
 #define COUPURE !((PINA & (1 << PA6)) || (PINA & (1 << PA5)) || (PINA & (1 << PA4)) || (PINA & (1 << PA3)) || (PINA & (1 << PA2)))
-
-#define LIGNE_CENTRE ((PINA & (1 << PA5)) ||  (PINA & (1 << PA4)) || (PINA & (1 << PA3)))
-
-
+#define LIGNE_CENTRE ((PINA & (1 << PA4)))
 
 //Valeur trouve par essai erreur pour redresser le robot 
-//Ces valeurs fonctionne bien pour le robot numero 17.
+//Ces valeurs fonctionne bien pour le robot numero 12 et 17 pour l'ajustement de lig.
 #define REDRESSEMENT_BAS 15
 #define REDRESSEMENT_MOYEN 30
 #define REDRESSEMENT_FORT 55
 #define REDRESSEEMNT_TRES_FORT 75
 
-
 #include "headers.h"
 
-
 class SuiveurLigneCytron_LSS05
 {
 public:
-    
     SuiveurLigneCytron_LSS05();
-    void detecterAngleDroit(bool& angleDroitAtteint); 
+    void detecterAngleDroit(bool& angleDroitAtteint);
     void detecterCoupure(bool& estCoupure);
     void detecterLigne(bool& estLigne); 
     void detecterLigneCentre(bool& estLigneCentre);
     void detecterCoupureCentre(bool& estCoupureCentre);
     void corrigerPWM(const uint8_t vitesse); // ajuste le PWM pour suivre la ligne.
     void corrigerPWMCouloir(const uint8_t vitesse);
-     
 };
 
 #endif // SUIVEUR_LIGNE_CYTRON_LSS05_H
\ No newline at end of file
diff --git a/lib/can.cpp b/lib/can.cpp
index 510a543..171f577 100644
--- a/lib/can.cpp
+++ b/lib/can.cpp
@@ -13,8 +13,7 @@
 #include "can.h"
 
 // constructeur: initialisation du convertisseur
-can::can()
-{
+can::can() {
    //Mettre le port A0 en entree pour lire les data analogique du capteur de lumiere
    DDRA &= ~(1 << PA0);
   
@@ -34,17 +33,14 @@ can::can()
 }
 
 // Destructeur:  Arreter le convertisseur pour sauver sur la consommation.
-can::~can()
-{
+can::~can(){
    // rendre le convertisseur inactif.
    ADCSRA = 0 << ADEN ;
 }
 
 // Faire une conversion et aller retourner le resultat sur 16 bits
 // dont seulement les 10 de poids faibles sont significatifs.
-uint16_t
-can::lecture( uint8_t pos)
-{
+uint16_t can::lecture( uint8_t pos){
    uint16_t adcVal;
 
    // Garder les bits de ADMUX intacts, sauf les bit permettant 
diff --git a/lib/can.h b/lib/can.h
index 239cc89..a2b1f4b 100644
--- a/lib/can.h
+++ b/lib/can.h
@@ -11,24 +11,21 @@
  *
  * Code qui n'est sous aucune license.
  *
- */
-
-#ifndef CAN_H
-#define CAN_H
-#include "headers.h"
-
-/*
+ *
  * Classe can:
  *   Le constructeur initialise le convertisseur.
  *   Une lecture enclanche une conversion et le resultat
  *   est retourne sur 16 bits.
  *
  */
+#ifndef CAN_H
+#define CAN_H
+
+#include "headers.h"
 
 class can
 {
    public:
-
       can();
       ~can();
 
@@ -37,9 +34,5 @@ class can
       // inclusivement.  Seulement les 10 bits de poids faible
       // sont significatifs.
       uint16_t lecture(uint8_t pos);
-
-   private:
-      // Donnees membres - aucun
-
 };
-#endif /* CAN_H */
+#endif // CAN_H
diff --git a/lib/commun.cpp b/lib/commun.cpp
index a57a6ca..bb1bf95 100644
--- a/lib/commun.cpp
+++ b/lib/commun.cpp
@@ -1,13 +1,13 @@
 #include "commun.h"
-namespace commun{
 
-void delai_ms(const uint16_t duree_ms = 1000){
-    for(unsigned int i = 0; i < duree_ms; i++)
-        _delay_ms(1);
-}
+namespace commun{
+    void delai_ms(const uint16_t duree_ms = 1000){
+        for(unsigned int i = 0; i < duree_ms; i++)
+            _delay_ms(1);
+    }
 
-void delai_us(const uint16_t duree_us = 10){
-    for(unsigned int i = 0; i < duree_us; i++)
-        _delay_us(1);
-}
-}
\ No newline at end of file
+    void delai_us(const uint16_t duree_us = 10){
+        for(unsigned int i = 0; i < duree_us; i++)
+            _delay_us(1);
+    }
+} // namespace commun
\ No newline at end of file
diff --git a/lib/commun.h b/lib/commun.h
index 2f57f0f..6e62418 100644
--- a/lib/commun.h
+++ b/lib/commun.h
@@ -3,10 +3,9 @@
 #include "headers.h"
 
 namespace commun{
-
     void delai_ms(const uint16_t duree_ms);
     void delai_us(const uint16_t duree_us);
-}
+} // namespace commun
 
-#endif
+#endif // COMMUN_H
 
diff --git a/lib/del.cpp b/lib/del.cpp
index 6d57c70..51eaab0 100644
--- a/lib/del.cpp
+++ b/lib/del.cpp
@@ -1,8 +1,8 @@
 #include "del.h"
 #include "commun.h"
+
 //Par defaut le PORTB est utilise
-DEL::DEL()
-{
+DEL::DEL(){
     PinMSB_ = 1;
     PinLSB_ = 0;
     DDRB |= (1 << PinMSB_) | ( 1 << PinLSB_); // PORTB1 et PORTB0 en mode sortie
@@ -10,8 +10,7 @@ DEL::DEL()
     portx_ = &PORTB;
 }
 
-DEL::DEL(volatile uint8_t* portx, volatile uint8_t*  ddrx)
-{
+DEL::DEL(volatile uint8_t* portx, volatile uint8_t*  ddrx){
     PinMSB_ = 1;
     PinLSB_ = 0;
     portx_ = portx;
@@ -20,49 +19,39 @@ DEL::DEL(volatile uint8_t* portx, volatile uint8_t*  ddrx)
 }
 
 //Cette fonction utilise par defaut les ports PX0 et PX1 d'un certain PORTX 
-void DEL::allumerDEL(const COULEUR couleurDEL)
-{    
-    switch (couleurDEL)
-    {  
+void DEL::allumerDEL(const COULEUR couleurDEL){    
+    switch (couleurDEL){  
     case VERTE:
        *portx_ &= ~(1 << PinMSB_);
         *portx_ |= (1 << PinLSB_);
         break;
-    
     case ROUGE:
         *portx_ &= ~(1 << PinLSB_);
         *portx_ |= (1 << PinMSB_);
         break;
-
     case OFF:
         *portx_ &= ~(1 << PinLSB_) & ~(1 << PinMSB_);
         break;
     }
 };
 
-void DEL::allumerDEL(const COULEUR couleurDEL, const uint16_t duree_ms)
-{
-    switch (couleurDEL)
-    {  
+void DEL::allumerDEL(const COULEUR couleurDEL, const uint16_t duree_ms){
+    switch (couleurDEL){  
     case VERTE:
         *portx_ &= ~(1 << PinMSB_);
         *portx_ |= (1 << PinLSB_);
-        
-        
         commun::delai_ms(duree_ms);
         *portx_ &= ~(1 << PinLSB_) & ~(1 << PinMSB_);
         break;
-    
     case ROUGE:
         *portx_ &= ~(1 << PinLSB_);
         *portx_ |= (1 << PinMSB_);
         commun::delai_ms(duree_ms);
         *portx_ &= ~(1 << PinLSB_) & ~(1 << PinMSB_);
         break;
-
     case OFF:
         *portx_ &= ~(1 << PinLSB_) & ~(1 << PinMSB_);
         commun::delai_ms(duree_ms);
         break;
     }
-};
+};
\ No newline at end of file
diff --git a/lib/del.h b/lib/del.h
index 87cd974..4d13cd1 100644
--- a/lib/del.h
+++ b/lib/del.h
@@ -7,7 +7,7 @@
  * ou
  * DEL del(A);
  *  
-*/
+ */
 
 #ifndef DEL_H //empecher de definir deux fois la DEL par erreur
 #define DEL_H
@@ -18,7 +18,6 @@ enum COULEUR {VERTE, ROUGE, OFF};
 class DEL 
 {
     public:
-
         DEL();
         DEL(volatile uint8_t* portx, volatile uint8_t* ddrx);
 
@@ -30,7 +29,6 @@ class DEL
         volatile uint8_t* ddrx_;
         uint8_t PinMSB_; // numéro de pin à utiliser sur le portx  (ayant Most Significant Bit)
         uint8_t PinLSB_; // numéro de pin à utiliser sur le portx (ayant Least Significant Bit)
-
 };
 #endif
 
diff --git a/lib/display.h b/lib/display.h
index a52e3ba..aff62ee 100644
--- a/lib/display.h
+++ b/lib/display.h
@@ -3,14 +3,13 @@
  * Nous avons decider d'utiliser le PORTC pour le display, car c'est le seul port qui est libre au complet et que la
  * mémoire ne sera pas utilisée dans le projet final.
  * 
-*/
-
-
+ */
 #ifndef DISPLAY_H
 #define DISPLAY_H
 
 #include "lcm_so1602dtr_m.h"
 #include "headers.h" 
+
 class Display{
     public:
         Display();
@@ -18,10 +17,8 @@ class Display{
         void ecrire(const char* data);
         void effacerAffichage();
 
-
     private:
         volatile uint8_t *port_, *ddr_;
-        
         void initDisplay(volatile uint8_t* ddr, volatile uint8_t*  port);
 };
 #endif
\ No newline at end of file
diff --git a/lib/interpreteur.cpp b/lib/interpreteur.cpp
index 643b9bf..74c08cc 100644
--- a/lib/interpreteur.cpp
+++ b/lib/interpreteur.cpp
@@ -24,8 +24,7 @@ void Interpreteur::parse_bytcode(uint8_t byte_code[]){
 
 
 void Interpreteur::executerByteCode(uint8_t code, uint8_t operande){
-    switch (code)
-    {
+    switch (code){
     //Si pour une raison il ya encore le opcode dbt alors qu'on a deja debuter le programme, ne rien faire et continuer
     case dbt_bc: // Routine de début
         ; //ne rien faire
diff --git a/lib/interrupt.cpp b/lib/interrupt.cpp
index a33ee95..94c293e 100644
--- a/lib/interrupt.cpp
+++ b/lib/interrupt.cpp
@@ -15,15 +15,12 @@ Interrupt::Interrupt(uint8_t id, TYPE_CONTROLE type = LOW_LEVEL)
 
 // Cette fonction doit etre utilisée dans une routine d'interruption, on assume qu'un délai de debounce est traité dans la routine.
 // Il n'est donc pas nécessaire d'ajouter de debounce explicite ici.
-bool Interrupt::isButtonPressed()
-{   
+bool Interrupt::isButtonPressed(){   
     return (*PINX & _BV(PX));
 };
 
-void Interrupt::initINTX(uint8_t id)
-{
-    switch (id)
-    {
+void Interrupt::initINTX(uint8_t id){
+    switch (id){
     case 0:
         PX = PD2;
         PINX = &PIND;
@@ -53,25 +50,20 @@ void Interrupt::initINTX(uint8_t id)
     }
 };
 
-void Interrupt::initEICRA(TYPE_CONTROLE type)
-{
-    switch (type)
-    {
+void Interrupt::initEICRA(TYPE_CONTROLE type){
+    switch (type){
     case LOW_LEVEL:
         EICRA = 0;
         break;
-
     case ANY_EDGE:
         EICRA |= _BV(ISCn0);
         break;
-
     case FALLING_EDGE:
         EICRA |= _BV(ISCn1);
         break;
-
     case RISING_EDGE:
         EICRA |= _BV(ISCn0);
         EICRA |= _BV(ISCn1);
         break;
     }
-};
+};
\ No newline at end of file
diff --git a/lib/interrupt.h b/lib/interrupt.h
index 1f307d4..feb5a0b 100644
--- a/lib/interrupt.h
+++ b/lib/interrupt.h
@@ -18,6 +18,7 @@
 
 #ifndef INTERRUPT_H
 #define INTERRUPT_H
+
 #include "headers.h"
 
 enum TYPE_CONTROLE {LOW_LEVEL, RISING_EDGE, FALLING_EDGE, ANY_EDGE};
@@ -34,10 +35,8 @@ class Interrupt
         volatile uint8_t* PINX;
         
         bool isButtonPressed();
-
     private:
         void initINTX(uint8_t id);
         void initEICRA(TYPE_CONTROLE type);
-
 };
-#endif
+#endif // INTERRUPT_H
\ No newline at end of file
diff --git a/lib/memoire_24.cpp b/lib/memoire_24.cpp
index d1fc601..10f86d8 100644
--- a/lib/memoire_24.cpp
+++ b/lib/memoire_24.cpp
@@ -28,7 +28,7 @@
 #ifndef F_CPU
 
 #define F_CPU 8000000UL
-#endif
+#endif // F_CPU
 
 #include "memoire_24.h"
 
diff --git a/lib/memoire_24.h b/lib/memoire_24.h
index 9f7ff9b..a1dd56a 100644
--- a/lib/memoire_24.h
+++ b/lib/memoire_24.h
@@ -54,13 +54,10 @@ public:
 
 private:
    // pour l'ecriture
-   uint8_t ecrire_page(const uint16_t adresse, uint8_t *donnee,
-                       const uint8_t longueur);
+   uint8_t ecrire_page(const uint16_t adresse, uint8_t *donnee, const uint8_t longueur);
 
-private:
    // donnees membres
    static uint8_t m_adresse_peripherique;
    const uint8_t PAGE_SIZE;
 };
-
 #endif /* MEMOIRE_24_H */
diff --git a/lib/minuterie.cpp b/lib/minuterie.cpp
index 89809e6..2ba0c4d 100644
--- a/lib/minuterie.cpp
+++ b/lib/minuterie.cpp
@@ -1,11 +1,7 @@
 #include "minuterie.h"
 
-
-
-
-//OC0A
-void startTimer0CTC(uint8_t duration, const uint8_t PBx /*= PB2 */){
-    
+void startTimer0CTC(uint8_t duration, const uint8_t PBx){
+    //OC0A
     //Ce timer sera utilise pour le piezo electrique, de ce fait on permet le choix a une pin adjacente
     //detre mis en mode sortie, car le piezo a besoin d'un 5V (timer) et dun ground.
     DDRB |= (1 << PB3) | ( 1 << PBx);
@@ -13,9 +9,8 @@ void startTimer0CTC(uint8_t duration, const uint8_t PBx /*= PB2 */){
     OCR0A = duration;
     TCCR0A |= (1 << COM0A0) | (1 << WGM01); // toggle OC0A on compare PB3;
     TCCR0B |= (1 << CS02); //prescaler 256, for midi notes
-    
-    
 }
+
 void stopTimer0CTC(){
     TCCR0A = 0;
     TCCR0B = 0;
@@ -23,12 +18,10 @@ void stopTimer0CTC(){
 }
 
 void partirMinuterie2CTC(){  
-
     TCCR2A = 0; //normal mode, le compteur TCNT2 va compter jusqua 255 et ensuite retombe 0
     //prescaler de 1024, pour atteindre le delai de 30ms du sonar sans overflow
     TCCR2B |= (1 << CS22) | (1 << CS21) | (1 << CS20);
     TCNT2 = 0;
-
 }
 
 void arreterMinuterie2CTC(){
diff --git a/lib/minuterie.h b/lib/minuterie.h
index d7d17c2..cc65666 100644
--- a/lib/minuterie.h
+++ b/lib/minuterie.h
@@ -1,11 +1,11 @@
 #ifndef MINUTERIE_H
 #define MINUTERIE_H
+
 #include "headers.h"
 
 void startTimer0CTC(const uint8_t duration, const uint8_t PBx = PB2);
 void stopTimer0CTC();
-
 void partirMinuterie2CTC();
 void arreterMinuterie2CTC();
 
-#endif
+#endif // MINUTERIE_H
diff --git a/lib/moteur.cpp b/lib/moteur.cpp
index 8cdaea9..99cfeef 100644
--- a/lib/moteur.cpp
+++ b/lib/moteur.cpp
@@ -1,38 +1,30 @@
 #include "moteur.h"
-// #include "debug.h"
+
 Moteur::Moteur(){
     DDRD |= (1 << PD4) | (1 << PD5) | ( 1 << PD6) | (1 << PD7); //Mise en sortie des ports
 }
 
-
-
 //Cette fonction sert de debug seulement pour le suiveur de ligne, car elle na aucune facon de sarreter pour le moment
-void Moteur::avancerLigne(const uint8_t vitesse)
-{
-
+void Moteur::avancerLigne(const uint8_t vitesse){
     avancer(vitesse);
-    while (1) //cette boucle va commencer pour dire au robot de suivre une ligne
+    while (true) //cette boucle va commencer pour dire au robot de suivre une ligne
     {
-
         suiveurLigne_.corrigerPWM(vitesse);
-        //commun::delai_ms(0);
     }
 }
 
-void Moteur::tournerProchaineLigne(bool aDroite, const uint8_t vitesse)
-{   
-    
+void Moteur::tournerProchaineLigne(bool aDroite, const uint8_t vitesse){   
     bool estLigne = false;
     if(aDroite){
         tournerDroite();
-    }else{
+    }
+    else{
         tournerGauche();
     }
     while (!estLigne) //cette boucle va commencer pour dire au robot de suivre une ligne
     {
         suiveurLigne_.detecterLigne(estLigne);
         suiveurLigne_.corrigerPWM(vitesse);
-        //commun::delai_ms(0);
     }
     arreter();
 }
@@ -45,69 +37,78 @@ void Moteur::avancer(uint8_t vitesse){ // Avance d'une distance en cm
 void Moteur::avancerProchainAngleDroit(const uint8_t vitesse){
     bool angleDroitAtteint = false;
     avancer(vitesse);
-    while (!angleDroitAtteint) // angleDroitAtteint_ est modifié par suiveur de ligne
-    {
 
+    // angleDroitAtteint est modifié par suiveur de ligne
+    while (!angleDroitAtteint){
         suiveurLigne_.detecterAngleDroit(angleDroitAtteint);
         suiveurLigne_.corrigerPWM(vitesse);
-        //commun::delai_ms(0);
     }
+    
+    //attendre un peu avant de sarreter pour que le capteur quitte le ruban
+    //ainsi lorsque le robot va tourner il aura une chance de detecter le prochain ruban
+    commun::delai_ms(500);
     arreter();
 }
 
+
 void Moteur::avancerProchaineCoupure(const uint8_t vitesse){
     bool estCoupure = false;
     avancer(vitesse);
-    while (!estCoupure) // angleDroitAtteint_ est modifié par suiveur de ligne
-    {
 
+    // estCoupure est modifié par suiveur de ligne
+    while (!estCoupure){
         suiveurLigne_.detecterCoupure(estCoupure);
         suiveurLigne_.corrigerPWM(vitesse);
-        //commun::delai_ms(0);
     }
     arreter();
 }
+
 void Moteur::avancerProchaineCoupureCentre(const uint8_t vitesse){
     bool estCoupureCentre = false;
     avancer(vitesse);
-    while(!estCoupureCentre){
 
+    // estCoupureCentre est modifié par suiveur de ligne
+    while(!estCoupureCentre){
         suiveurLigne_.detecterCoupureCentre(estCoupureCentre);
         suiveurLigne_.corrigerPWM(vitesse);
-        //commun::delai_ms(0);
-        
     }
     arreter();
 }
+
 void Moteur::avancerAjustementMur(const uint8_t vitesse){
     bool estLigne = false;
-    
     avancer(vitesse);
+    
+    // estCoupureCentre est modifié par sonar
     while(!estLigne){
+        //Le sonar est en cours de codage, ne pas enlever ces commentaires svp
         sonar_.envoyerSignal();
         sonar_.ecouterEcho();
         suiveurLigne_.detecterLigne(estLigne);
         
         //Si la distance est plus grande que 15 cm
         if(sonar_.pulse_width > (15 * 58)){
-            OCR1A = vitesse + 40; //augmenter la roue droite
-            OCR1B = vitesse - 40; //diminuer la roue gauche
+            OCR1A = vitesse + REDRESSEMENT_MOYEN; //augmenter la roue droite
+            OCR1B = vitesse - REDRESSEMENT_MOYEN; //diminuer la roue gauche
         }
         else if(sonar_.pulse_width < (15 * 58)){
-            OCR1A = vitesse - 40; //augmenter la roue droite
-            OCR1B = vitesse + 40; //diminuer la roue gauche
+            OCR1A = vitesse - REDRESSEMENT_MOYEN; //augmenter la roue droite
+            OCR1B = vitesse + REDRESSEMENT_MOYEN; //diminuer la roue gauche
         }
         else{
             OCR1A = vitesse;
             OCR1B = vitesse;
         }
-        // commun::delai_ms(0);
+        //ajuster a chaque 60ms
+        commun::delai_ms(60);
     }
 }
 
 void Moteur::avancerAjustementCouloir(uint8_t vitesse){
     bool estLigneCentre = false;
     avancer(vitesse);
+
+    // estLigneCentre est modifié par suiveur de ligne
     while(!estLigneCentre){
         suiveurLigne_.detecterLigneCentre(estLigneCentre);
         suiveurLigne_.corrigerPWMCouloir(vitesse);
@@ -116,15 +117,12 @@ void Moteur::avancerAjustementCouloir(uint8_t vitesse){
 }
 
 
-void Moteur::reculer(const uint8_t vitesse)
-{
+void Moteur::reculer(const uint8_t vitesse){
     PORTD |= (1 << PD7) | (1 << PD6);
     ajusterPWM(vitesse, vitesse);
 }
 
-
-void Moteur::arreter()
-{
+void Moteur::arreter(){
     OCR1A = 0;
     OCR1B = 0;
     TCCR1A = 0;
@@ -132,29 +130,19 @@ void Moteur::arreter()
     TCCR1C = 0;    
 }
 
-void Moteur::tournerDroite()
-{
+void Moteur::tournerDroite(){
     ajusterPWM(0.50*0xFF, 0);
 }
 
-
-
-void Moteur::tournerGauche()
-{
-    
+void Moteur::tournerGauche(){
     ajusterPWM(0, 0.50*0xFF);
-    
 }
 
-
-
-void Moteur::ajusterPWM(const uint8_t roueG, const uint8_t roueD)
-{
+void Moteur::ajusterPWM(const uint8_t roueG, const uint8_t roueD){
     OCR1A = roueD;
     OCR1B = roueG;
 
     TCCR1A |= (1 << COM1A1) | (1 << WGM10) | (1 << COM1B1);
     TCCR1B |= (1 << CS11) ;
     TCCR1C = 0;
-}
-
+}
\ No newline at end of file
diff --git a/lib/moteur.h b/lib/moteur.h
index feb91f2..783ff31 100644
--- a/lib/moteur.h
+++ b/lib/moteur.h
@@ -1,10 +1,12 @@
 #ifndef MOTEUR_H
 #define MOTEUR_H
+
 #include "headers.h"
 #include "commun.h"
 #include "SuiveurLigneCytron_LSS05.h"
 #include "sonar.h"
 
+
 class Moteur
 {
     public:
@@ -21,10 +23,10 @@ class Moteur
         void avancerProchaineCoupureCentre(const uint8_t vitesse);
         void reculer(const uint8_t vitesse);
         void arreter();
-    private:
         
+    private:
         void ajusterPWM(const uint8_t roueG, const uint8_t roueD);
         SuiveurLigneCytron_LSS05 suiveurLigne_;
         Sonar sonar_;
 };
-#endif
\ No newline at end of file
+#endif // MOTEUR_H
\ No newline at end of file
diff --git a/lib/notes.h b/lib/notes.h
index ba99c7d..22e4f0e 100644
--- a/lib/notes.h
+++ b/lib/notes.h
@@ -1,9 +1,12 @@
 #ifndef NOTES_H
 #define NOTES_H
+
 #include "headers.h"
 #include "commun.h"
 #include "minuterie.h"
+
 void playNote(uint8_t note = 45, const uint16_t duree_ms = 300);
 void playNote(uint8_t note, const uint16_t duree_ms, const uint8_t nRepetition);
 void stopNote();
-#endif
\ No newline at end of file
+
+#endif // NOTES_H
\ No newline at end of file
diff --git a/lib/sonar.cpp b/lib/sonar.cpp
index 24dea1c..e69a2ae 100644
--- a/lib/sonar.cpp
+++ b/lib/sonar.cpp
@@ -1,39 +1,44 @@
 #include "sonar.h"
 
 Sonar::Sonar(){
-    
-    initSonar();
+    //Mettre le A0 en mode sortie et le pin A1 en mode entree
+    DDRA |= (1 << PA0);
+    //Mettre la minuterie 2 en mode CTC, prescaler a 1024
+    // TCCR2A |= (1 << WGM21);
+    // TCCR2B |= (1 << CS21) | (1 << CS11) | (1 << CS10);
+    // TIMSK2 |= (1 << OCIE2A);
+    // OCR2A = 255;
 }
 /*
  * Pour commencer a sonder un objet il faut envoyer un signal de trigger, pendant environ 10us minimum. 
  * La pin pour le signal trigger est A0 
 */
-// Permets d'envoyer un signal manuellement TRIGGER
-void Sonar::envoyerSignal(){
-cli();
-    PORTA |= _BV(PA0);
-    _delay_us(15);
-    PORTA &= ~(1 << PA0);
-sei();
-}
+// Permets d'envoyer un signal manuellement
+// ISR(TIMER2_COMPA_vect){
+//     _delay_ms(20);
+// cli();
+//     PORTA |= _BV(PA0);
+//     _delay_us(15);
+//     PORTA &= ~(1 << PA0);
+// sei();
+// }
 // Attends jusqu'à recevoir un signal
 void Sonar::ecouterEcho(){
-// cli();
+
     while(!(PINA & _BV(PA1))){}
-//    int x = TCNT2;
     int count = 0;
     while((PINA & _BV(PA1))){
         _delay_us(0.5);
         count++;
     };
-    pulse_width = count;
-    distance = pulse_width / 58;
-// sei();
+    wavelength = count;
+    distance = wavelength/58;
 }
 
-void Sonar::initSonar(){
-    //Mettre le A0 en mode sortie et le pin A1 en mode entree
-    DDRA |= (1 << PA0);
-    // DDRA &= ~(1 << PA1);
-    
+void Sonar::envoyerSignal(){
+    cli();
+    PORTA |= _BV(PA0);
+    _delay_us(15);
+    PORTA &= ~(1 << PA0);
+    sei();
 }
diff --git a/lib/sonar.h b/lib/sonar.h
index 5771cad..21dedd8 100644
--- a/lib/sonar.h
+++ b/lib/sonar.h
@@ -8,23 +8,24 @@
 #include "headers.h"
 #include "commun.h"
 
+
+const int accuracy = 4;   // Incertitude associee au sonar en cm
+const int maximum_effective_range = 517; // Distance maximale que le sonar peut trouver en cm.
+
+
 class Sonar {
     public:
         Sonar();
         void envoyerSignal();
         void initSonar();
         void ecouterEcho();
-        uint16_t obtenirDistance();
-        bool distanceAObjet(int desired_range);
-        bool distanceAObjet(int desired_range, int incertitude);
-        bool isObject();
-        uint16_t pulse_width;
-        uint8_t distance;
+        int estAutourDe(uint8_t distance);
+        int estAutourDe(uint8_t distance, uint8_t incertitude);
+        bool estPlusLoinQue();
+        bool estPlusProcheQue();
         int desired_range; // Distance que l'on veut
-        const int accuracy = 4;   // Incertitude associee au sonar en cm
-        const int maximum_effective_range = 517; // Distance maximale que le sonar peut trouver en cm.
-    private:
-        
-        
+        uint16_t pulse_width;
+        uint64_t wavelength;
+        int distance;
 };
 #endif
\ No newline at end of file
diff --git a/lib/uart.cpp b/lib/uart.cpp
index 5c7fdce..f5c93cf 100644
--- a/lib/uart.cpp
+++ b/lib/uart.cpp
@@ -1,38 +1,34 @@
 #include "uart.h"
 
-
-UART::UART()
-{
+UART::UART(){
     initUART();
 }
 
-void UART::transmissionUART(uint8_t donnee)
-{
+void UART::transmissionUART(uint8_t donnee){
     //Wait for empty transmit buffer
-    while(!(UCSR0A & (1<< UDRE0)))
-    ;
+    while(!(UCSR0A & (1<< UDRE0))){
+        _delay_ms(1);
+    }
     UDR0 = donnee;
 }
 
-unsigned char UART::receptionUART()
-{
+unsigned char UART::receptionUART(){
    //Attente de donnee
-   while (!(UCSR0A & (1<<RXC0)) )
-   ;
+   while (!(UCSR0A & (1<<RXC0)) ){
+        _delay_ms(1);
+    }
             
    return UDR0;
 };
 
-
-void UART::initUART()
-{   
+void UART::initUART(){   
+    // permettre la réception et la transmission par le UART0
     UBRR0H = 0;
     UBRR0L = 0xCF;
-    // permettre la réception et la transmission par le UART0
-    // UCSR0A = '';
-    // il nest pas necessaire d'ajuster ce registre 
+
     //Enable Transmission and reception
     UCSR0B |= (1<<RXEN0) | (1 << TXEN0);
+
     // Format des trames: 8 bits (UCSZ01 et UCSZ00) (3<<UCSZn0) par defaut deja a 1 
     //, 1 stop bits (USBSn = 0), none parity (UPMN) ;
     UCSR0C |= (1<<UCSZ00) | (1<<UCSZ01);
diff --git a/lib/uart.h b/lib/uart.h
index 5cdc2d4..92cfa05 100644
--- a/lib/uart.h
+++ b/lib/uart.h
@@ -3,7 +3,7 @@
 
 #include "headers.h"
 
-class UART 
+class UART
 {
     public:
         UART();
diff --git a/projet/LISEZMOI.txt b/projet/LISEZMOI.txt
index ede6b2d..771338e 100644
--- a/projet/LISEZMOI.txt
+++ b/projet/LISEZMOI.txt
@@ -30,7 +30,7 @@ D0      |
 D1      |
 D2      |   INT0 Boutton Poussoir
 D3      |   INT1 Boutton Blanc
-D4      |   PWM Roue Gauche
-D5      |   PWM Roue Droite
+D4      |   PWM Roue Gauche OCR1B
+D5      |   PWM Roue Droite OCR1A
 D6      |   Direction Roue Gauche
 D7      |   Direction Roue Droite
\ No newline at end of file
diff --git a/projet/main.cpp b/projet/main.cpp
index 36e30e7..48635c9 100644
--- a/projet/main.cpp
+++ b/projet/main.cpp
@@ -1,13 +1,9 @@
-#include "interrupt.h"
-#include "minuterie.h"
 #include "robot.h"
-#include "del.h"
-#include "debug.h"
 #include "display.h"
+#include "commun.h"
+#include "interrupt.h"
 #include "sonar.h"
 #include "uart.h"
-//DEL temporaire pour tests
-DEL del; // TODO enlever
 
 //Initialisation des bouttons
 Interrupt bouttonBlanc(1, FALLING_EDGE);
@@ -18,43 +14,56 @@ volatile bool boutonInterruptAppuye = false;
 volatile bool actualiserLCD = true; //Cette boolean est utile pour ne pas ecrire dans le display LCD a linfini, mais seulement une fois.
 
 //interrupt causé par le bouton blanc
-ISR(INT1_vect){
+ISR(INT1_vect)
+{
     //anti rebond
     commun::delai_ms(20);
 
     //negation car le boutton blanc agit de facon inverse
-    if (!bouttonBlanc.isButtonPressed()) {
+    if (!bouttonBlanc.isButtonPressed()) 
+    {
         nbAppuies++;
         actualiserLCD = true;
     }
     
 }
 
-ISR(INT0_vect){
+//Interrupt cause par le boutton poussoir
+ISR(INT0_vect)
+{
     //anti rebond
     commun::delai_ms(20);
     if(bouttonPoussoir.isButtonPressed())
         boutonInterruptAppuye = true;
 }
-bool angle = false;
-// Appuyer sur boutton reset
-int main(){
-    
-    Robot robot;
+
+int main()
+{ 
+    /* **************************************************
+     * ZONE DE TEST POUR LE CAPTEUR DE LIGNE ET MOTEUR  *
+     * **************************************************/
     Moteur moteur;
     uint8_t vitesse = 0.4 * 0xff;
+    moteur.avancerAjustementMur(vitesse);
+    
 
-    // // moteur.avancerLigne(vitesse);
-    // moteur.avancerProchaineCoupureCentre(vitesse);
-    // moteur.avancerAjustementCouloir(vitesse);
-    // moteur.avancerProchainAngleDroit(vitesse);
-    // for(;;){}
+
+    /****************************************************
+     *               FIN DE LA ZONE DE TEST             *
+     ****************************************************/
+
+    /********************************
+    *   DEBUT PROGRAMME PRINCIPAL   *
+    *********************************/
+
+    Robot robot;
+    
     //Detecter nb appuie bouton blanc jusqu'à l'appuie du bouton interrupt
     while (!boutonInterruptAppuye)
     {
         //Changer l'etat seulement lorsque le boutton est appuye, ce qui fait que le display LCD ne se rafraichit qu'une seule fois.
-        if(actualiserLCD){
-            // DEBUG_PRINT("nb app %d\n", nbAppuies);
+        if(actualiserLCD)
+        {    
             switch (nbAppuies % 4) // Selection circulaire de la section avec le bouton blanc
             {
             case COULOIR:
@@ -70,7 +79,6 @@ int main(){
                 robot.setSectionInitial(COUPURES);
                 break;    
             }
-
             robot.afficherSection();
             actualiserLCD = false;
         }
diff --git a/projet/  b/projet/robot.cpp
index 45c6529..ff35ea8 100644
--- a/projet/robot.cpp
+++ b/projet/robot.cpp
@@ -1,5 +1,4 @@
 #include "robot.h"
-#include "debug.h"
 
 Robot::Robot(){
     section_ = COULOIR; //par defaut la section initial a afficher dans le display est LE COULOIR 
@@ -13,8 +12,7 @@ void Robot::setSectionInitial(Section section){
 }
 
 void Robot::afficherSection(){
-    switch (section_)
-    {
+    switch (section_){
     case COULOIR: // affiche « le couloir »
             display_.ecrire("LE COULOIR");
         break;
@@ -40,8 +38,7 @@ void Robot::effectuerRoutineDebut(){
 }
 
 void Robot::changerEtat(){
-    switch (section_)
-    {
+    switch (section_){
     case COULOIR:
         if(sectionInitial_ != MUR)
             section_ = MUR;
@@ -78,8 +75,7 @@ void Robot::changerEtat(Section section){
 }
 
 void Robot::effectuerEtat(){
-    switch (section_)
-    {
+    switch (section_){
     case COULOIR:
         effectuerCouloir_();
         effectuerTransition_(COULOIR_MUR);
@@ -110,19 +106,25 @@ bool Robot::estTerminee(){
 
 void Robot::effectuerCouloir_(){
     // Position A direction AB
-    //TODO
+    moteur_.avancerProchaineCoupureCentre(vitesse_);
     // Bondir entre les segments CD et EF
-    // Position G direction GH
+    moteur_.avancerAjustementCouloir(vitesse_);
+
+    // Position G direction GH et sarreter a langle droit.
+    moteur_.avancerProchainAngleDroit(vitesse_);
+    moteur_.arreter();
+    
 }
 
 void Robot::effectuerMur_(){
     // Position H direction HI
-    //TODO
-    // Segment JK
-    // changer direction
-    // Position K direction KL
+    moteur_.avancerProchaineCoupure(vitesse_);
+    //Suivre le mur
+    moteur_.avancerAjustementMur(vitesse_);
 
-    moteur_.avancerAjustementMur(vitesse_);  
+    // Segment JK-KL
+    moteur_.avancerProchainAngleDroit(vitesse_);
+    moteur_.arreter();
 }
 
 void Robot::effectuerBoucles_(){
@@ -147,7 +149,6 @@ void Robot::effectuerBoucles_(){
 void Robot::effectuerCoupures_(){
     // Position T direction TU
     // Segment TU
-    DEBUG_PRINT("JE FAIT LES COUPURES");
     moteur_.avancerProchaineCoupure(vitesse_);
     commun::delai_ms(500);
     //Jouer un son aigu a la coupure V
@@ -179,7 +180,8 @@ void Robot::effectuerCoupures_(){
     playNote(45);
     moteur_.tournerProchaineLigne(false, vitesse_);
     stopNote();
-    //Passer a la transitions pour le segment 6A
+    //Passer le segment 6A et sarreter a langle droit
+    moteur_.avancerProchainAngleDroit(vitesse_);
     moteur_.arreter();
 
 }
@@ -193,50 +195,41 @@ void Robot::effectuerFin_(){
 }
 
 void Robot::effectuerTransition_(Transition transition){
-    switch (transition)
-    {
+    switch (transition){
     case COULOIR_MUR:
         if (sectionInitial_ != MUR)
         {
-            // Position G direction GH
-            // Segment GH
-            //TODO
-            //moteur_.avancer() à déterminée
-            // moteur_.tournerGauche(); // Position H direction HI
+            commun::delai_ms(500);
+            //tourner et sarreter des quil detecte une ligne
+            moteur_.tournerProchaineLigne(false, vitesse_);
         }
         break;
     case MUR_BOUCLES:
         if (sectionInitial_ != BOUCLES)
         {
-            // Position K direction KL
-            // Segment KL
-            //TODO
-            //moteur_.avancer() à déterminée
-            // moteur_.tournerGauche(); // Position L direction LM
+            commun::delai_ms(500);
+            //tourner a gauche et sarreter des quil detecte une ligne
+            moteur_.tournerProchaineLigne(false, vitesse_);
         }
         break;
     case BOUCLES_COUPURES:
         if (sectionInitial_ != COUPURES)
         {
-            // Position O direction OT
-            
-            // Segment OT
-            //TODO
-            //moteur_.avancer() à déterminée
-            // moteur_.tournerGauche(); // Position T direction TU
+            commun::delai_ms(500);
+            //tourner a gauche et sarreter des quil detecte une ligne
+            moteur_.tournerProchaineLigne(false, vitesse_);
         }
         break;
     case COUPURES_COULOIR:
         if (sectionInitial_ != COULOIR)
         {
-            // Position 6 direction 6A
-            // Segment 6A
-            
-            moteur_.avancerProchainAngleDroit(vitesse_);
-            // TODO moteur_.tournerGauche(); // Position A direction AB
+            commun::delai_ms(500);
+            //tourner a gauche et sarreter des quil detecte une ligne
+            moteur_.tournerProchaineLigne(false, vitesse_);
+                    
         }
         break;                    
     default:
         break;
     }
-}
+}
\ No newline at end of file
diff --git a/projet/robot.h b/projet/robot.h
index 70789c1..fed3108 100644
--- a/projet/robot.h
+++ b/projet/robot.h
@@ -1,5 +1,6 @@
 #ifndef ROBOT_H
 #define ROBOT_H
+
 #include "headers.h"
 #include "commun.h"
 #include "moteur.h"
@@ -8,6 +9,7 @@
 #include "minuterie.h"
 #include "display.h"
 #include "notes.h"
+
 enum Section {COULOIR, MUR, BOUCLES, COUPURES, FIN};
 enum Transition {COULOIR_MUR, MUR_BOUCLES, BOUCLES_COUPURES, COUPURES_COULOIR};
 
diff --git a/tp/tp9/sortie b/tp/tp9/sortie
new file mode 100644
index 0000000..4112962
Binary files /dev/null and b/tp/tp9/sortie differ
diff --git a/tp/tp9/test.s b/tp/tp9/test.s
new file mode 100644
index 0000000..356b5bb
--- /dev/null
+++ b/tp/tp9/test.s
@@ -0,0 +1,24 @@
+trd;
+dbt;
+mav 255;
+att 40;
+mar;
+att 40;
+trd;
+att 40;
+mav 255;
+att 40;
+mar;
+att 40;
+trg;
+att 40;
+mav 255;
+att 40;
+mar;
+att 40;
+mre 255;
+att 40;
+mar;
+att 40;
+fin;
+dal 1;
\ No newline at end of file
diff --git a/tp/tp9/write_byte_code/progmem/Makefile b/tp/tp9/write_byte_code/progmem/Makefile
new file mode 100644
index 0000000..f0e6235
--- /dev/null
+++ b/tp/tp9/write_byte_code/progmem/Makefile
@@ -0,0 +1,37 @@
+
+# name of the final exacutable to be built goes here
+BIN = progmem
+
+# name of the source files without any extension
+SRCNAME = $(BIN)
+
+CC = g++
+
+# CFLAGS = -g
+# CCFLAGS = -DCPLUSPLUS -g  # for use with C++ if file ext is .cc
+CFLAGS = -DCPLUSPLUS -g  # for use with C++ if file ext is .c
+
+SRCS = $(SRCNAME).y $(SRCNAME).l
+OBJS = $(SRCNAME).yy.o $(SRCNAME).tab.o
+LIBS = -lfl -lm 
+
+$(BIN): $(OBJS)
+	$(CC) $(CCFLAGS) $(OBJS) $(LIBS) -o $(BIN)
+
+$(SRCNAME).tab.h $(SRCNAME).tab.c: $(SRCNAME).y
+	bison -v -t -d $(SRCNAME).y  
+
+$(SRCNAME).yy.c: $(SRCNAME).l $(SRCNAME).tab.h
+	flex -o$(SRCNAME).yy.c $(SRCNAME).l
+	sed -e 's/\"syntax error\"/\"erreur de syntaxe\"/g' $(SRCNAME).tab.c  > tmp
+	mv tmp $(SRCNAME).tab.c
+	rm -f tmp
+
+all:    
+	touch $(SRCS)
+	make
+
+clean:
+	rm -f $(OBJS) $(BIN) $(SRCNAME).yy.c \
+		$(SRCNAME).tab.h $(SRCNAME).tab.c $(SRCNAME).output
+
diff --git a/tp/tp9/write_byte_code/progmem/progmem b/tp/tp9/write_byte_code/progmem/progmem
new file mode 100755
index 0000000..e6286ed
Binary files /dev/null and b/tp/tp9/write_byte_code/progmem/progmem differ
diff --git a/tp/tp9/write_byte_code/progmem/progmem.l b/tp/tp9/write_byte_code/progmem/progmem.l
new file mode 100644
index 0000000..a1458a1
--- /dev/null
+++ b/tp/tp9/write_byte_code/progmem/progmem.l
@@ -0,0 +1,83 @@
+/*
+    Progmem: fichier Flex pour l'analyse lexical des instructions
+             du compilateur qui genere le bytecode pour le cours inf1995
+
+    Jerome Collin
+    Juin 2005
+*/
+
+%{
+
+#include "progmem.tab.h"
+
+int ligne = 1;
+extern void yyerror ( char const *s);
+
+%}
+
+DIGIT    [0-9]
+INTEGER  {DIGIT}+
+
+%%
+
+[ \t]+          /* ignorer les espaces */
+[\n]       { ligne++; }
+[\r]            /* ignorer les \r, tenir compte uniquement du /n */
+
+                /* passer les lignes de commentaire */
+\/\/[^\n]*
+#[^\n]*
+"%"[^\n]*
+
+                /* reconnaitre les mots reserves */
+
+DBT|dbt { return DBT; }
+FIN|fin { return FIN; }
+ATT|att { return ATT; }
+DAL|dal { return DAL; }
+DET|det { return DET; }
+SGO|sgo { return SGO; }
+SAR|sar { return SAR; }
+MAR|mar { return MAR; }
+MAV|mav { return MAV; }
+MRE|mre { return MRE; }
+TRD|trd { return TRD; }
+TRG|trg { return TRG; }
+DBC|dbc { return DBC; }
+FBC|fbc { return FBC; }
+
+                /* la donnee est toujours un entier */
+{INTEGER}  {
+             yylval.typeString = yytext;
+             return DONNEE;
+           }
+
+;  { return POINTVIRGULE; }
+
+               /* tout autre caratere est un probleme */
+[a-zA-Z0-9]+  { return MAUVAISJETON; }
+
+.  { yyerror ( "character non reconnu"); }
+
+%%
+
+// Un seul fichier a analyser - aucun support pour un genre de fichier
+// "include" - ne rien faire
+int yywrap () {
+   return 1;
+}
+
+// Pour tout ce qui doit etre fait avant que l'analyse lexical ne debute
+// Ouvrire le fichier source pour y lire les instructions
+int prologLexical ( const char *fichier ) {
+   yyin = fopen( fichier, "r" );
+   if ( yyin == NULL ) {
+       fprintf (stderr, "Erreur: incapable d'ouvrir le fichier source %s\n",
+                                                              fichier );
+       return 0; // code d'erreur
+   }
+
+   return 1; // succes
+}
+
+
diff --git a/tp/tp9/write_byte_code/progmem/progmem.output b/tp/tp9/write_byte_code/progmem/progmem.output
new file mode 100644
index 0000000..64eb373
--- /dev/null
+++ b/tp/tp9/write_byte_code/progmem/progmem.output
@@ -0,0 +1,275 @@
+Terminals unused in grammar
+
+   MAUVAISJETON
+
+
+Grammar
+
+    0 $accept: instructions $end
+
+    1 instructions: %empty
+    2             | instructions instruction POINTVIRGULE
+    3             | instructions error POINTVIRGULE
+
+    4 instruction: mnemonique1
+    5            | mnemonique2 valeur
+
+    6 mnemonique1: DBT
+    7            | FIN
+    8            | SAR
+    9            | MAR
+   10            | TRD
+   11            | TRG
+   12            | DBC
+   13            | FBC
+
+   14 mnemonique2: ATT
+   15            | DAL
+   16            | DET
+   17            | SGO
+   18            | MAV
+   19            | MRE
+   20            | DBC
+
+   21 valeur: DONNEE
+
+
+Terminals, with rules where they appear
+
+$end (0) 0
+error (256) 3
+DBT (258) 6
+FIN (259) 7
+ATT (260) 14
+DAL (261) 15
+DET (262) 16
+SGO (263) 17
+SAR (264) 8
+MAR (265) 9
+MAV (266) 18
+MRE (267) 19
+TRD (268) 10
+TRG (269) 11
+DBC (270) 12 20
+FBC (271) 13
+DONNEE (272) 21
+POINTVIRGULE (273) 2 3
+MAUVAISJETON (274)
+
+
+Nonterminals, with rules where they appear
+
+$accept (20)
+    on left: 0
+instructions (21)
+    on left: 1 2 3, on right: 0 2 3
+instruction (22)
+    on left: 4 5, on right: 2
+mnemonique1 (23)
+    on left: 6 7 8 9 10 11 12 13, on right: 4
+mnemonique2 (24)
+    on left: 14 15 16 17 18 19 20, on right: 5
+valeur (25)
+    on left: 21, on right: 5
+
+
+State 0
+
+    0 $accept: . instructions $end
+
+    $default  reduce using rule 1 (instructions)
+
+    instructions  go to state 1
+
+
+State 1
+
+    0 $accept: instructions . $end
+    2 instructions: instructions . instruction POINTVIRGULE
+    3             | instructions . error POINTVIRGULE
+
+    $end   shift, and go to state 2
+    error  shift, and go to state 3
+    DBT    shift, and go to state 4
+    FIN    shift, and go to state 5
+    ATT    shift, and go to state 6
+    DAL    shift, and go to state 7
+    DET    shift, and go to state 8
+    SGO    shift, and go to state 9
+    SAR    shift, and go to state 10
+    MAR    shift, and go to state 11
+    MAV    shift, and go to state 12
+    MRE    shift, and go to state 13
+    TRD    shift, and go to state 14
+    TRG    shift, and go to state 15
+    DBC    shift, and go to state 16
+    FBC    shift, and go to state 17
+
+    instruction  go to state 18
+    mnemonique1  go to state 19
+    mnemonique2  go to state 20
+
+
+State 2
+
+    0 $accept: instructions $end .
+
+    $default  accept
+
+
+State 3
+
+    3 instructions: instructions error . POINTVIRGULE
+
+    POINTVIRGULE  shift, and go to state 21
+
+
+State 4
+
+    6 mnemonique1: DBT .
+
+    $default  reduce using rule 6 (mnemonique1)
+
+
+State 5
+
+    7 mnemonique1: FIN .
+
+    $default  reduce using rule 7 (mnemonique1)
+
+
+State 6
+
+   14 mnemonique2: ATT .
+
+    $default  reduce using rule 14 (mnemonique2)
+
+
+State 7
+
+   15 mnemonique2: DAL .
+
+    $default  reduce using rule 15 (mnemonique2)
+
+
+State 8
+
+   16 mnemonique2: DET .
+
+    $default  reduce using rule 16 (mnemonique2)
+
+
+State 9
+
+   17 mnemonique2: SGO .
+
+    $default  reduce using rule 17 (mnemonique2)
+
+
+State 10
+
+    8 mnemonique1: SAR .
+
+    $default  reduce using rule 8 (mnemonique1)
+
+
+State 11
+
+    9 mnemonique1: MAR .
+
+    $default  reduce using rule 9 (mnemonique1)
+
+
+State 12
+
+   18 mnemonique2: MAV .
+
+    $default  reduce using rule 18 (mnemonique2)
+
+
+State 13
+
+   19 mnemonique2: MRE .
+
+    $default  reduce using rule 19 (mnemonique2)
+
+
+State 14
+
+   10 mnemonique1: TRD .
+
+    $default  reduce using rule 10 (mnemonique1)
+
+
+State 15
+
+   11 mnemonique1: TRG .
+
+    $default  reduce using rule 11 (mnemonique1)
+
+
+State 16
+
+   12 mnemonique1: DBC .
+   20 mnemonique2: DBC .
+
+    DONNEE    reduce using rule 20 (mnemonique2)
+    $default  reduce using rule 12 (mnemonique1)
+
+
+State 17
+
+   13 mnemonique1: FBC .
+
+    $default  reduce using rule 13 (mnemonique1)
+
+
+State 18
+
+    2 instructions: instructions instruction . POINTVIRGULE
+
+    POINTVIRGULE  shift, and go to state 22
+
+
+State 19
+
+    4 instruction: mnemonique1 .
+
+    $default  reduce using rule 4 (instruction)
+
+
+State 20
+
+    5 instruction: mnemonique2 . valeur
+
+    DONNEE  shift, and go to state 23
+
+    valeur  go to state 24
+
+
+State 21
+
+    3 instructions: instructions error POINTVIRGULE .
+
+    $default  reduce using rule 3 (instructions)
+
+
+State 22
+
+    2 instructions: instructions instruction POINTVIRGULE .
+
+    $default  reduce using rule 2 (instructions)
+
+
+State 23
+
+   21 valeur: DONNEE .
+
+    $default  reduce using rule 21 (valeur)
+
+
+State 24
+
+    5 instruction: mnemonique2 valeur .
+
+    $default  reduce using rule 5 (instruction)
diff --git a/tp/tp9/write_byte_code/progmem/progmem.tab.c b/tp/tp9/write_byte_code/progmem/progmem.tab.c
new file mode 100644
index 0000000..ce35c1f
--- /dev/null
+++ b/tp/tp9/write_byte_code/progmem/progmem.tab.c
@@ -0,0 +1,1716 @@
+/* A Bison parser, made by GNU Bison 3.0.2.  */
+
+/* Bison implementation for Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989-1990, 2000-2013 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "3.0.2"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
+
+
+
+/* Copy the first part of user declarations.  */
+#line 9 "progmem.y" /* yacc.c:339  */
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+// deux procedures standards avec lex/yacc
+int yylex (void);
+void yyerror (char const *);
+
+extern int ligne;  // pour identifier la ligne qui cause l'erreur
+
+// pour initialiser avant l'analyse lexicale
+extern int prologLexical ( const char *fichier );
+
+FILE *fichierSortie;  // fichier binaire produit
+int erreurs = 0; // pour rapporter le nombre d'erreur de compilation
+int verbose = 0; // pour donner plus d'information sur la compilation
+int nOctets = 2; // nombre d'octets du fichier binaire
+
+
+#line 88 "progmem.tab.c" /* yacc.c:339  */
+
+# ifndef YY_NULLPTR
+#  if defined __cplusplus && 201103L <= __cplusplus
+#   define YY_NULLPTR nullptr
+#  else
+#   define YY_NULLPTR 0
+#  endif
+# endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* In a future release of Bison, this section will be replaced
+   by #include "progmem.tab.h".  */
+#ifndef YY_YY_PROGMEM_TAB_H_INCLUDED
+# define YY_YY_PROGMEM_TAB_H_INCLUDED
+/* Debug traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 1
+#endif
+#if YYDEBUG
+extern int yydebug;
+#endif
+
+/* Token type.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+  enum yytokentype
+  {
+    DBT = 258,
+    FIN = 259,
+    ATT = 260,
+    DAL = 261,
+    DET = 262,
+    SGO = 263,
+    SAR = 264,
+    MAR = 265,
+    MAV = 266,
+    MRE = 267,
+    TRD = 268,
+    TRG = 269,
+    DBC = 270,
+    FBC = 271,
+    DONNEE = 272,
+    POINTVIRGULE = 273,
+    MAUVAISJETON = 274
+  };
+#endif
+
+/* Value type.  */
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE YYSTYPE;
+union YYSTYPE
+{
+#line 52 "progmem.y" /* yacc.c:355  */
+
+   int typeInt;
+   char *typeString;
+
+#line 153 "progmem.tab.c" /* yacc.c:355  */
+};
+# define YYSTYPE_IS_TRIVIAL 1
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+extern YYSTYPE yylval;
+
+int yyparse (void);
+
+#endif /* !YY_YY_PROGMEM_TAB_H_INCLUDED  */
+
+/* Copy the second part of user declarations.  */
+
+#line 168 "progmem.tab.c" /* yacc.c:358  */
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#else
+typedef signed char yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if defined YYENABLE_NLS && YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(Msgid) dgettext ("bison-runtime", Msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(Msgid) Msgid
+# endif
+#endif
+
+#ifndef YY_ATTRIBUTE
+# if (defined __GNUC__                                               \
+      && (2 < __GNUC__ || (__GNUC__ == 2 && 96 <= __GNUC_MINOR__)))  \
+     || defined __SUNPRO_C && 0x5110 <= __SUNPRO_C
+#  define YY_ATTRIBUTE(Spec) __attribute__(Spec)
+# else
+#  define YY_ATTRIBUTE(Spec) /* empty */
+# endif
+#endif
+
+#ifndef YY_ATTRIBUTE_PURE
+# define YY_ATTRIBUTE_PURE   YY_ATTRIBUTE ((__pure__))
+#endif
+
+#ifndef YY_ATTRIBUTE_UNUSED
+# define YY_ATTRIBUTE_UNUSED YY_ATTRIBUTE ((__unused__))
+#endif
+
+#if !defined _Noreturn \
+     && (!defined __STDC_VERSION__ || __STDC_VERSION__ < 201112)
+# if defined _MSC_VER && 1200 <= _MSC_VER
+#  define _Noreturn __declspec (noreturn)
+# else
+#  define _Noreturn YY_ATTRIBUTE ((__noreturn__))
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(E) ((void) (E))
+#else
+# define YYUSE(E) /* empty */
+#endif
+
+#if defined __GNUC__ && 407 <= __GNUC__ * 100 + __GNUC_MINOR__
+/* Suppress an incorrect diagnostic about yylval being uninitialized.  */
+# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN \
+    _Pragma ("GCC diagnostic push") \
+    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")\
+    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END \
+    _Pragma ("GCC diagnostic pop")
+#else
+# define YY_INITIAL_VALUE(Value) Value
+#endif
+#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END
+#endif
+#ifndef YY_INITIAL_VALUE
+# define YY_INITIAL_VALUE(Value) /* Nothing. */
+#endif
+
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+      /* Use EXIT_SUCCESS as a witness for stdlib.h.  */
+#     ifndef EXIT_SUCCESS
+#      define EXIT_SUCCESS 0
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's 'empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
+       && ! ((defined YYMALLOC || defined malloc) \
+             && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef EXIT_SUCCESS
+#    define EXIT_SUCCESS 0
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined EXIT_SUCCESS
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined EXIT_SUCCESS
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+         || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+# define YYCOPY_NEEDED 1
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \
+    do                                                                  \
+      {                                                                 \
+        YYSIZE_T yynewbytes;                                            \
+        YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \
+        Stack = &yyptr->Stack_alloc;                                    \
+        yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+        yyptr += yynewbytes / sizeof (*yyptr);                          \
+      }                                                                 \
+    while (0)
+
+#endif
+
+#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
+/* Copy COUNT objects from SRC to DST.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(Dst, Src, Count) \
+      __builtin_memcpy (Dst, Src, (Count) * sizeof (*(Src)))
+#  else
+#   define YYCOPY(Dst, Src, Count)              \
+      do                                        \
+        {                                       \
+          YYSIZE_T yyi;                         \
+          for (yyi = 0; yyi < (Count); yyi++)   \
+            (Dst)[yyi] = (Src)[yyi];            \
+        }                                       \
+      while (0)
+#  endif
+# endif
+#endif /* !YYCOPY_NEEDED */
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  2
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   19
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  20
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  6
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  22
+/* YYNSTATES -- Number of states.  */
+#define YYNSTATES  25
+
+/* YYTRANSLATE[YYX] -- Symbol number corresponding to YYX as returned
+   by yylex, with out-of-bounds checking.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   274
+
+#define YYTRANSLATE(YYX)                                                \
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
+   as returned by yylex, without out-of-bounds checking.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19
+};
+
+#if YYDEBUG
+  /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
+static const yytype_uint8 yyrline[] =
+{
+       0,    70,    70,    72,    73,    77,    86,   100,   101,   102,
+     103,   104,   105,   106,   107,   112,   113,   114,   115,   116,
+     117,   118,   121
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || 0
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "DBT", "FIN", "ATT", "DAL", "DET", "SGO",
+  "SAR", "MAR", "MAV", "MRE", "TRD", "TRG", "DBC", "FBC", "DONNEE",
+  "POINTVIRGULE", "MAUVAISJETON", "$accept", "instructions", "instruction",
+  "mnemonique1", "mnemonique2", "valeur", YY_NULLPTR
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[NUM] -- (External) token number corresponding to the
+   (internal) symbol number NUM (which must be that of a token).  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274
+};
+# endif
+
+#define YYPACT_NINF -17
+
+#define yypact_value_is_default(Yystate) \
+  (!!((Yystate) == (-17)))
+
+#define YYTABLE_NINF -22
+
+#define yytable_value_is_error(Yytable_value) \
+  0
+
+  /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+     STATE-NUM.  */
+static const yytype_int8 yypact[] =
+{
+     -17,     0,   -17,   -16,   -17,   -17,   -17,   -17,   -17,   -17,
+     -17,   -17,   -17,   -17,   -17,   -17,     1,   -17,    -1,   -17,
+       2,   -17,   -17,   -17,   -17
+};
+
+  /* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
+     Performed when YYTABLE does not specify something else to do.  Zero
+     means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       2,     0,     1,     0,     7,     8,    15,    16,    17,    18,
+       9,    10,    19,    20,    11,    12,    13,    14,     0,     5,
+       0,     4,     3,    22,     6
+};
+
+  /* YYPGOTO[NTERM-NUM].  */
+static const yytype_int8 yypgoto[] =
+{
+     -17,   -17,   -17,   -17,   -17,   -17
+};
+
+  /* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int8 yydefgoto[] =
+{
+      -1,     1,    18,    19,    20,    24
+};
+
+  /* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
+     positive, shift that token.  If negative, reduce the rule whose
+     number is the opposite.  If YYTABLE_NINF, syntax error.  */
+static const yytype_int8 yytable[] =
+{
+       2,     3,    21,     4,     5,     6,     7,     8,     9,    10,
+      11,    12,    13,    14,    15,    16,    17,    22,   -21,    23
+};
+
+static const yytype_uint8 yycheck[] =
+{
+       0,     1,    18,     3,     4,     5,     6,     7,     8,     9,
+      10,    11,    12,    13,    14,    15,    16,    18,    17,    17
+};
+
+  /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+     symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,    21,     0,     1,     3,     4,     5,     6,     7,     8,
+       9,    10,    11,    12,    13,    14,    15,    16,    22,    23,
+      24,    18,    18,    17,    25
+};
+
+  /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,    20,    21,    21,    21,    22,    22,    23,    23,    23,
+      23,    23,    23,    23,    23,    24,    24,    24,    24,    24,
+      24,    24,    25
+};
+
+  /* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     0,     3,     3,     1,     2,     1,     1,     1,
+       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
+       1,     1,     1
+};
+
+
+#define yyerrok         (yyerrstatus = 0)
+#define yyclearin       (yychar = YYEMPTY)
+#define YYEMPTY         (-2)
+#define YYEOF           0
+
+#define YYACCEPT        goto yyacceptlab
+#define YYABORT         goto yyabortlab
+#define YYERROR         goto yyerrorlab
+
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)                                  \
+do                                                              \
+  if (yychar == YYEMPTY)                                        \
+    {                                                           \
+      yychar = (Token);                                         \
+      yylval = (Value);                                         \
+      YYPOPSTACK (yylen);                                       \
+      yystate = *yyssp;                                         \
+      goto yybackup;                                            \
+    }                                                           \
+  else                                                          \
+    {                                                           \
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;                                                  \
+    }                                                           \
+while (0)
+
+/* Error token number */
+#define YYTERROR        1
+#define YYERRCODE       256
+
+
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)                        \
+do {                                            \
+  if (yydebug)                                  \
+    YYFPRINTF Args;                             \
+} while (0)
+
+/* This macro is provided for backward compatibility. */
+#ifndef YY_LOCATION_PRINT
+# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+#endif
+
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                    \
+do {                                                                      \
+  if (yydebug)                                                            \
+    {                                                                     \
+      YYFPRINTF (stderr, "%s ", Title);                                   \
+      yy_symbol_print (stderr,                                            \
+                  Type, Value); \
+      YYFPRINTF (stderr, "\n");                                           \
+    }                                                                     \
+} while (0)
+
+
+/*----------------------------------------.
+| Print this symbol's value on YYOUTPUT.  |
+`----------------------------------------*/
+
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+{
+  FILE *yyo = yyoutput;
+  YYUSE (yyo);
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# endif
+  YYUSE (yytype);
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+{
+  YYFPRINTF (yyoutput, "%s %s (",
+             yytype < YYNTOKENS ? "token" : "nterm", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+static void
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)                            \
+do {                                                            \
+  if (yydebug)                                                  \
+    yy_stack_print ((Bottom), (Top));                           \
+} while (0)
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+static void
+yy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, int yyrule)
+{
+  unsigned long int yylno = yyrline[yyrule];
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+             yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr,
+                       yystos[yyssp[yyi + 1 - yynrhs]],
+                       &(yyvsp[(yyi + 1) - (yynrhs)])
+                                              );
+      YYFPRINTF (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)          \
+do {                                    \
+  if (yydebug)                          \
+    yy_reduce_print (yyssp, yyvsp, Rule); \
+} while (0)
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+static YYSIZE_T
+yystrlen (const char *yystr)
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+        switch (*++yyp)
+          {
+          case '\'':
+          case ',':
+            goto do_not_strip_quotes;
+
+          case '\\':
+            if (*++yyp != '\\')
+              goto do_not_strip_quotes;
+            /* Fall through.  */
+          default:
+            if (yyres)
+              yyres[yyn] = *yyp;
+            yyn++;
+            break;
+
+          case '"':
+            if (yyres)
+              yyres[yyn] = '\0';
+            return yyn;
+          }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
+   about the unexpected token YYTOKEN for the state stack whose top is
+   YYSSP.
+
+   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
+   not large enough to hold the message.  In that case, also set
+   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
+   required number of bytes is too large to store.  */
+static int
+yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
+                yytype_int16 *yyssp, int yytoken)
+{
+  YYSIZE_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);
+  YYSIZE_T yysize = yysize0;
+  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+  /* Internationalized format string. */
+  const char *yyformat = YY_NULLPTR;
+  /* Arguments of yyformat. */
+  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+  /* Number of reported tokens (one for the "unexpected", one per
+     "expected"). */
+  int yycount = 0;
+
+  /* There are many possibilities here to consider:
+     - If this state is a consistent state with a default action, then
+       the only way this function was invoked is if the default action
+       is an error action.  In that case, don't check for expected
+       tokens because there are none.
+     - The only way there can be no lookahead present (in yychar) is if
+       this state is a consistent state with a default action.  Thus,
+       detecting the absence of a lookahead is sufficient to determine
+       that there is no unexpected or expected token to report.  In that
+       case, just report a simple "erreur de syntaxe".
+     - Don't assume there isn't a lookahead just because this state is a
+       consistent state with a default action.  There might have been a
+       previous inconsistent state, consistent state with a non-default
+       action, or user semantic action that manipulated yychar.
+     - Of course, the expected token list depends on states to have
+       correct lookahead information, and it depends on the parser not
+       to perform extra reductions after fetching a lookahead from the
+       scanner and before detecting a syntax error.  Thus, state merging
+       (from LALR or IELR) and default reductions corrupt the expected
+       token list.  However, the list is correct for canonical LR with
+       one exception: it will still contain any token that will not be
+       accepted due to an error action in a later state.
+  */
+  if (yytoken != YYEMPTY)
+    {
+      int yyn = yypact[*yyssp];
+      yyarg[yycount++] = yytname[yytoken];
+      if (!yypact_value_is_default (yyn))
+        {
+          /* Start YYX at -YYN if negative to avoid negative indexes in
+             YYCHECK.  In other words, skip the first -YYN actions for
+             this state because they are default actions.  */
+          int yyxbegin = yyn < 0 ? -yyn : 0;
+          /* Stay within bounds of both yycheck and yytname.  */
+          int yychecklim = YYLAST - yyn + 1;
+          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+          int yyx;
+
+          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
+                && !yytable_value_is_error (yytable[yyx + yyn]))
+              {
+                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+                  {
+                    yycount = 1;
+                    yysize = yysize0;
+                    break;
+                  }
+                yyarg[yycount++] = yytname[yyx];
+                {
+                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);
+                  if (! (yysize <= yysize1
+                         && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+                    return 2;
+                  yysize = yysize1;
+                }
+              }
+        }
+    }
+
+  switch (yycount)
+    {
+# define YYCASE_(N, S)                      \
+      case N:                               \
+        yyformat = S;                       \
+      break
+      YYCASE_(0, YY_("erreur de syntaxe"));
+      YYCASE_(1, YY_("syntax error, unexpected %s"));
+      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
+      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
+      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
+      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
+# undef YYCASE_
+    }
+
+  {
+    YYSIZE_T yysize1 = yysize + yystrlen (yyformat);
+    if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+      return 2;
+    yysize = yysize1;
+  }
+
+  if (*yymsg_alloc < yysize)
+    {
+      *yymsg_alloc = 2 * yysize;
+      if (! (yysize <= *yymsg_alloc
+             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
+        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
+      return 1;
+    }
+
+  /* Avoid sprintf, as that infringes on the user's name space.
+     Don't have undefined behavior even if the translation
+     produced a string with the wrong number of "%s"s.  */
+  {
+    char *yyp = *yymsg;
+    int yyi = 0;
+    while ((*yyp = *yyformat) != '\0')
+      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
+        {
+          yyp += yytnamerr (yyp, yyarg[yyi++]);
+          yyformat += 2;
+        }
+      else
+        {
+          yyp++;
+          yyformat++;
+        }
+  }
+  return 0;
+}
+#endif /* YYERROR_VERBOSE */
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+{
+  YYUSE (yyvaluep);
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  YYUSE (yytype);
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+}
+
+
+
+
+/* The lookahead symbol.  */
+int yychar;
+
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+/*----------.
+| yyparse.  |
+`----------*/
+
+int
+yyparse (void)
+{
+    int yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       'yyss': related to states.
+       'yyvs': related to semantic values.
+
+       Refer to the stacks through separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
+
+    YYSIZE_T yystacksize;
+
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken = 0;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  yyssp = yyss = yyssa;
+  yyvsp = yyvs = yyvsa;
+  yystacksize = YYINITDEPTH;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY; /* Cause a token to be read.  */
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+        /* Give user a chance to reallocate the stack.  Use copies of
+           these so that the &'s don't force the real ones into
+           memory.  */
+        YYSTYPE *yyvs1 = yyvs;
+        yytype_int16 *yyss1 = yyss;
+
+        /* Each stack pointer address is followed by the size of the
+           data in use in that stack, in bytes.  This used to be a
+           conditional around just the two extra args, but that might
+           be undefined if yyoverflow is a macro.  */
+        yyoverflow (YY_("memory exhausted"),
+                    &yyss1, yysize * sizeof (*yyssp),
+                    &yyvs1, yysize * sizeof (*yyvsp),
+                    &yystacksize);
+
+        yyss = yyss1;
+        yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+        goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+        yystacksize = YYMAXDEPTH;
+
+      {
+        yytype_int16 *yyss1 = yyss;
+        union yyalloc *yyptr =
+          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+        if (! yyptr)
+          goto yyexhaustedlab;
+        YYSTACK_RELOCATE (yyss_alloc, yyss);
+        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+#  undef YYSTACK_RELOCATE
+        if (yyss1 != yyssa)
+          YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+                  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+        YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+  yyn = yypact[yystate];
+  if (yypact_value_is_default (yyn))
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = yylex ();
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yytable_value_is_error (yyn))
+        goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the lookahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
+
+  yystate = yyn;
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  *++yyvsp = yylval;
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     '$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 5:
+#line 78 "progmem.y" /* yacc.c:1646  */
+    {
+                if ( verbose > 0 ) {
+                   fprintf ( stdout, " - %#.2X - OX00 - ligne %d\n", (yyvsp[0].typeInt), ligne);
+                }
+                // inscription dans le fichier binaire
+                fprintf ( fichierSortie, "%c%c", (unsigned char)(yyvsp[0].typeInt), 0);
+                nOctets += 2;
+              }
+#line 1259 "progmem.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 6:
+#line 87 "progmem.y" /* yacc.c:1646  */
+    {
+                if ( verbose > 0 ) {
+                   fprintf ( stdout, " - %#.2X - %#.2X - ligne %d\n", (yyvsp[-1].typeInt), (yyvsp[0].typeInt), ligne);
+                }
+                // inscription dans le fichier binaire
+                fprintf ( fichierSortie, "%c%c", (unsigned char)(yyvsp[-1].typeInt),
+                                                 (unsigned char)(yyvsp[0].typeInt) );
+                nOctets += 2;
+              }
+#line 1273 "progmem.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 7:
+#line 100 "progmem.y" /* yacc.c:1646  */
+    { (yyval.typeInt) = 0x01; }
+#line 1279 "progmem.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 8:
+#line 101 "progmem.y" /* yacc.c:1646  */
+    { (yyval.typeInt) = 0xFF; }
+#line 1285 "progmem.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 9:
+#line 102 "progmem.y" /* yacc.c:1646  */
+    { (yyval.typeInt) = 0x09; }
+#line 1291 "progmem.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 10:
+#line 103 "progmem.y" /* yacc.c:1646  */
+    { (yyval.typeInt) = 0x61; }
+#line 1297 "progmem.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 11:
+#line 104 "progmem.y" /* yacc.c:1646  */
+    { (yyval.typeInt) = 0x64; }
+#line 1303 "progmem.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 12:
+#line 105 "progmem.y" /* yacc.c:1646  */
+    { (yyval.typeInt) = 0x65; }
+#line 1309 "progmem.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 13:
+#line 106 "progmem.y" /* yacc.c:1646  */
+    { (yyval.typeInt) = 0xC0; }
+#line 1315 "progmem.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 14:
+#line 107 "progmem.y" /* yacc.c:1646  */
+    { (yyval.typeInt) = 0xC1; }
+#line 1321 "progmem.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 15:
+#line 112 "progmem.y" /* yacc.c:1646  */
+    { (yyval.typeInt) = 0x02; }
+#line 1327 "progmem.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 16:
+#line 113 "progmem.y" /* yacc.c:1646  */
+    { (yyval.typeInt) = 0x44; }
+#line 1333 "progmem.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 17:
+#line 114 "progmem.y" /* yacc.c:1646  */
+    { (yyval.typeInt) = 0x45; }
+#line 1339 "progmem.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 18:
+#line 115 "progmem.y" /* yacc.c:1646  */
+    { (yyval.typeInt) = 0x48; }
+#line 1345 "progmem.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 19:
+#line 116 "progmem.y" /* yacc.c:1646  */
+    { (yyval.typeInt) = 0x62; }
+#line 1351 "progmem.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 20:
+#line 117 "progmem.y" /* yacc.c:1646  */
+    { (yyval.typeInt) = 0x63; }
+#line 1357 "progmem.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 21:
+#line 118 "progmem.y" /* yacc.c:1646  */
+    { (yyval.typeInt) = 0xC0; }
+#line 1363 "progmem.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 22:
+#line 121 "progmem.y" /* yacc.c:1646  */
+    {
+                   char *inutil;
+                   long int entier = strtol ( (yyvsp[0].typeString), &inutil, 10 );
+                   if ( entier < 0 || entier > 255 ) {
+                      yyerror ("donnee invalide");
+                   }
+                   (yyval.typeInt) = (int)entier;
+                }
+#line 1376 "progmem.tab.c" /* yacc.c:1646  */
+    break;
+
+
+#line 1380 "progmem.tab.c" /* yacc.c:1646  */
+      default: break;
+    }
+  /* User semantic actions sometimes alter yychar, and that requires
+     that yytoken be updated with the new translation.  We take the
+     approach of translating immediately before every use of yytoken.
+     One alternative is translating here after every semantic action,
+     but that translation would be missed if the semantic action invokes
+     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
+     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
+     incorrect destructor might then be invoked immediately.  In the
+     case of YYERROR or YYBACKUP, subsequent parser actions might lead
+     to an incorrect destructor call or verbose syntax error message
+     before the lookahead is translated.  */
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+  /* Now 'shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*--------------------------------------.
+| yyerrlab -- here on detecting error.  |
+`--------------------------------------*/
+yyerrlab:
+  /* Make sure we have latest lookahead translation.  See comments at
+     user semantic actions for why this is necessary.  */
+  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
+
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("erreur de syntaxe"));
+#else
+# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
+                                        yyssp, yytoken)
+      {
+        char const *yymsgp = YY_("erreur de syntaxe");
+        int yysyntax_error_status;
+        yysyntax_error_status = YYSYNTAX_ERROR;
+        if (yysyntax_error_status == 0)
+          yymsgp = yymsg;
+        else if (yysyntax_error_status == 1)
+          {
+            if (yymsg != yymsgbuf)
+              YYSTACK_FREE (yymsg);
+            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
+            if (!yymsg)
+              {
+                yymsg = yymsgbuf;
+                yymsg_alloc = sizeof yymsgbuf;
+                yysyntax_error_status = 2;
+              }
+            else
+              {
+                yysyntax_error_status = YYSYNTAX_ERROR;
+                yymsgp = yymsg;
+              }
+          }
+        yyerror (yymsgp);
+        if (yysyntax_error_status == 2)
+          goto yyexhaustedlab;
+      }
+# undef YYSYNTAX_ERROR
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+         error, discard it.  */
+
+      if (yychar <= YYEOF)
+        {
+          /* Return failure if at end of input.  */
+          if (yychar == YYEOF)
+            YYABORT;
+        }
+      else
+        {
+          yydestruct ("Error: discarding",
+                      yytoken, &yylval);
+          yychar = YYEMPTY;
+        }
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule whose action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;      /* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (!yypact_value_is_default (yyn))
+        {
+          yyn += YYTERROR;
+          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+            {
+              yyn = yytable[yyn];
+              if (0 < yyn)
+                break;
+            }
+        }
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+        YYABORT;
+
+
+      yydestruct ("Error: popping",
+                  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  *++yyvsp = yylval;
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#if !defined yyoverflow || YYERROR_VERBOSE
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEMPTY)
+    {
+      /* Make sure we have latest lookahead translation.  See comments at
+         user semantic actions for why this is necessary.  */
+      yytoken = YYTRANSLATE (yychar);
+      yydestruct ("Cleanup: discarding lookahead",
+                  yytoken, &yylval);
+    }
+  /* Do not reclaim the symbols of the rule whose action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+                  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  return yyresult;
+}
+#line 131 "progmem.y" /* yacc.c:1906  */
+
+
+void
+yyerror (char const *s) {
+   erreurs++;
+   fprintf ( stderr, "Erreur: ligne %d, %s\n", ligne, s );
+}
+
+void afficherAide() {
+   fprintf (stderr, "\nprogmem : -v -o <fichier> <fichier>\n\n");
+   fprintf (stderr, "  -v --verbose : affichage des codes a l'ecran\n");
+   fprintf (stderr, "  -o --output <fichier> : fichier de sortie binaire\n");
+   fprintf (stderr, "  <fichier> : fichier a compiler\n\n");
+   exit (EXIT_FAILURE);
+}
+
+int main ( int argc, char *argv[] ) {
+   int fichierEntreeOK = 0;
+   int fichierSortieOK = 0;
+   int nomFichierSortie = 0;
+
+
+   // analyze de la ligne de commande
+   int i = 1;
+   while ( i < argc ) {
+      if ( strcmp (argv[i], "-o") == 0 ||
+           strcmp (argv[i], "--output") == 0 ) {
+         i++;
+         if ( i < argc && strlen( argv[i] ) < 99 ) {
+            fichierSortie = fopen (argv[i], "w");
+            if ( fichierSortie == NULL ) {
+               fprintf (stderr, "Erreur: incapable d'ouvrir le fichier" );
+               fprintf (stderr, " binaire de sortie\n");
+               afficherAide();
+            }
+            fichierSortieOK = 1;
+            nomFichierSortie = i;
+
+            // 16 bits de longueur de fichier binaire.
+            // A ajuster en fin de compilation. Voir plus bas.
+            fprintf ( fichierSortie, "%c%c", 0, 0 );
+         }
+         else {
+            fprintf (stderr, "Erreur: arguments incorrects\n");
+            afficherAide();
+         }
+      }
+      else if ( strcmp (argv[i], "-v") == 0 ||
+         strcmp (argv[i], "--verbose") == 0 ) {
+         verbose = 1;
+      }
+      else {
+         if ( i == argc - 1 ) {
+            if ( prologLexical(argv[i]) == 0 ) {
+               afficherAide();
+            }
+            fichierEntreeOK = 1;
+         }
+         else {
+            afficherAide();
+         }
+      }
+      i++;
+   }
+
+   if ( fichierEntreeOK == 0 || fichierSortieOK == 0 ) {
+      fprintf (stderr,
+             "\nErreur: fichier de sortie et/ou d'entree non specifie(s)\n");
+      exit (EXIT_FAILURE);
+   }
+
+   // Afficher les resultats de traduction a l'usager, si desire
+   if ( verbose > 0 ) {
+      fprintf (stderr, "\n   CMD   DONNEE  LIGNE\n");
+      fprintf (stderr, "   ---   ------  -----\n");
+   }
+
+   // Faire l'analyse lexical et syntaxique du fichier a compiler
+   if ( yyparse() || erreurs > 0 ) {
+      // retourner un code d'erreur (1)
+      fprintf (stderr, "\n*** compilation terminee sans succes ***\n\n");
+      remove ( argv[nomFichierSortie] );  // ne rien produire - minimiser les problemes
+      exit (EXIT_FAILURE);
+   }
+
+   // ajuster la longueur du fichier binaire en debut de fichier binaire
+   if ( fseek (fichierSortie, 0, SEEK_SET) == 0 ) {
+      unsigned char poidsFaible = (unsigned char) nOctets;
+      unsigned char poidsFort   = (unsigned char) (nOctets >> 8);
+      fprintf ( fichierSortie, "%c%c", poidsFort, poidsFaible );
+   }
+   else {
+      // retourner un code d'erreur (1)
+      fprintf (stderr, "\n*** incapable de determiner la longueur du fichier binaire ***\n\n");
+      remove ( argv[nomFichierSortie] );
+      exit (EXIT_FAILURE);
+   }
+
+   // Donner le compte du nombre d'octets dans le fichier binaire
+   if ( verbose > 0 ) {
+      fprintf (stderr, "\n   Nombre d'octets dans le fichier binaire produit: %d\n\n", nOctets);
+   }
+
+   // retourner le code unix standard pour un succes (utile pour
+   // usage dans un Makefile par exemple)
+   exit (EXIT_SUCCESS);
+}
+
+
diff --git a/tp/tp9/write_byte_code/progmem/progmem.tab.h b/tp/tp9/write_byte_code/progmem/progmem.tab.h
new file mode 100644
index 0000000..8cd7157
--- /dev/null
+++ b/tp/tp9/write_byte_code/progmem/progmem.tab.h
@@ -0,0 +1,89 @@
+/* A Bison parser, made by GNU Bison 3.0.2.  */
+
+/* Bison interface for Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989-1990, 2000-2013 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+#ifndef YY_YY_PROGMEM_TAB_H_INCLUDED
+# define YY_YY_PROGMEM_TAB_H_INCLUDED
+/* Debug traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 1
+#endif
+#if YYDEBUG
+extern int yydebug;
+#endif
+
+/* Token type.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+  enum yytokentype
+  {
+    DBT = 258,
+    FIN = 259,
+    ATT = 260,
+    DAL = 261,
+    DET = 262,
+    SGO = 263,
+    SAR = 264,
+    MAR = 265,
+    MAV = 266,
+    MRE = 267,
+    TRD = 268,
+    TRG = 269,
+    DBC = 270,
+    FBC = 271,
+    DONNEE = 272,
+    POINTVIRGULE = 273,
+    MAUVAISJETON = 274
+  };
+#endif
+
+/* Value type.  */
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE YYSTYPE;
+union YYSTYPE
+{
+#line 52 "progmem.y" /* yacc.c:1909  */
+
+   int typeInt;
+   char *typeString;
+
+#line 79 "progmem.tab.h" /* yacc.c:1909  */
+};
+# define YYSTYPE_IS_TRIVIAL 1
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+extern YYSTYPE yylval;
+
+int yyparse (void);
+
+#endif /* !YY_YY_PROGMEM_TAB_H_INCLUDED  */
diff --git a/tp/tp9/write_byte_code/progmem/progmem.y b/tp/tp9/write_byte_code/progmem/progmem.y
new file mode 100644
index 0000000..ea6f5be
--- /dev/null
+++ b/tp/tp9/write_byte_code/progmem/progmem.y
@@ -0,0 +1,239 @@
+/*
+    Progmem: fichier Bison pour l'analyse syntaxique des instructions
+             du compilateur qui genere le bytecode pour le cours inf1995
+
+    Jerome Collin
+    Juin 2005
+*/
+
+%{
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+// deux procedures standards avec lex/yacc
+int yylex (void);
+void yyerror (char const *);
+
+extern int ligne;  // pour identifier la ligne qui cause l'erreur
+
+// pour initialiser avant l'analyse lexicale
+extern int prologLexical ( const char *fichier );
+
+FILE *fichierSortie;  // fichier binaire produit
+int erreurs = 0; // pour rapporter le nombre d'erreur de compilation
+int verbose = 0; // pour donner plus d'information sur la compilation
+int nOctets = 2; // nombre d'octets du fichier binaire
+
+%}
+
+// jeton du langage
+// voir www.cours.polymtl.ca/inf1995/tp/tp9 pour le description du langage
+%token DBT
+%token FIN
+%token ATT
+%token DAL
+%token DET
+%token SGO
+%token SAR
+%token MAR
+%token MAV
+%token MRE
+%token TRD
+%token TRG
+%token DBC
+%token FBC
+%token DONNEE
+%token POINTVIRGULE
+%token MAUVAISJETON
+
+// retour soit d'entier ou de chaines de caracteres pour les regles yacc
+%union {
+   int typeInt;
+   char *typeString;
+}
+
+// types possibles pour les regles
+%type <typeString> DONNEE
+%type <typeInt> mnemonique1 mnemonique2 valeur
+
+%expect 0
+%verbose
+
+%start instructions
+
+%%
+
+// regles YACC
+
+instructions :
+           /* aucune instruction */
+          | instructions instruction POINTVIRGULE
+          | instructions error       POINTVIRGULE
+          ;
+
+instruction :
+             mnemonique1
+              {
+                if ( verbose > 0 ) {
+                   fprintf ( stdout, " - %#.2X - OX00 - ligne %d\n", $1, ligne);
+                }
+                // inscription dans le fichier binaire
+                fprintf ( fichierSortie, "%c%c", (unsigned char)$1, 0);
+                nOctets += 2;
+              }
+           | mnemonique2 valeur
+              {
+                if ( verbose > 0 ) {
+                   fprintf ( stdout, " - %#.2X - %#.2X - ligne %d\n", $1, $2, ligne);
+                }
+                // inscription dans le fichier binaire
+                fprintf ( fichierSortie, "%c%c", (unsigned char)$1,
+                                                 (unsigned char)$2 );
+                nOctets += 2;
+              }
+          ;
+
+// sans operande significatif
+mnemonique1 : 
+            DBT { $$ = 0x01; }
+          | FIN { $$ = 0xFF; }
+          | SAR { $$ = 0x09; }
+          | MAR { $$ = 0x61; }
+          | TRD { $$ = 0x64; }
+          | TRG { $$ = 0x65; }
+          | DBC { $$ = 0xC0; }
+          | FBC { $$ = 0xC1; }
+          ;
+
+// avec operande significatif
+mnemonique2 :
+            ATT { $$ = 0x02; }
+          | DAL { $$ = 0x44; }
+          | DET { $$ = 0x45; }
+          | SGO { $$ = 0x48; }
+          | MAV { $$ = 0x62; }
+          | MRE { $$ = 0x63; }
+          | DBC { $$ = 0xC0; }
+          ;
+
+valeur : DONNEE {
+                   char *inutil;
+                   long int entier = strtol ( $1, &inutil, 10 );
+                   if ( entier < 0 || entier > 255 ) {
+                      yyerror ("donnee invalide");
+                   }
+                   $$ = (int)entier;
+                }
+          ;
+
+%%
+
+void
+yyerror (char const *s) {
+   erreurs++;
+   fprintf ( stderr, "Erreur: ligne %d, %s\n", ligne, s );
+}
+
+void afficherAide() {
+   fprintf (stderr, "\nprogmem : -v -o <fichier> <fichier>\n\n");
+   fprintf (stderr, "  -v --verbose : affichage des codes a l'ecran\n");
+   fprintf (stderr, "  -o --output <fichier> : fichier de sortie binaire\n");
+   fprintf (stderr, "  <fichier> : fichier a compiler\n\n");
+   exit (EXIT_FAILURE);
+}
+
+int main ( int argc, char *argv[] ) {
+   int fichierEntreeOK = 0;
+   int fichierSortieOK = 0;
+   int nomFichierSortie = 0;
+
+
+   // analyze de la ligne de commande
+   int i = 1;
+   while ( i < argc ) {
+      if ( strcmp (argv[i], "-o") == 0 ||
+           strcmp (argv[i], "--output") == 0 ) {
+         i++;
+         if ( i < argc && strlen( argv[i] ) < 99 ) {
+            fichierSortie = fopen (argv[i], "w");
+            if ( fichierSortie == NULL ) {
+               fprintf (stderr, "Erreur: incapable d'ouvrir le fichier" );
+               fprintf (stderr, " binaire de sortie\n");
+               afficherAide();
+            }
+            fichierSortieOK = 1;
+            nomFichierSortie = i;
+
+            // 16 bits de longueur de fichier binaire.
+            // A ajuster en fin de compilation. Voir plus bas.
+            fprintf ( fichierSortie, "%c%c", 0, 0 );
+         }
+         else {
+            fprintf (stderr, "Erreur: arguments incorrects\n");
+            afficherAide();
+         }
+      }
+      else if ( strcmp (argv[i], "-v") == 0 ||
+         strcmp (argv[i], "--verbose") == 0 ) {
+         verbose = 1;
+      }
+      else {
+         if ( i == argc - 1 ) {
+            if ( prologLexical(argv[i]) == 0 ) {
+               afficherAide();
+            }
+            fichierEntreeOK = 1;
+         }
+         else {
+            afficherAide();
+         }
+      }
+      i++;
+   }
+
+   if ( fichierEntreeOK == 0 || fichierSortieOK == 0 ) {
+      fprintf (stderr,
+             "\nErreur: fichier de sortie et/ou d'entree non specifie(s)\n");
+      exit (EXIT_FAILURE);
+   }
+
+   // Afficher les resultats de traduction a l'usager, si desire
+   if ( verbose > 0 ) {
+      fprintf (stderr, "\n   CMD   DONNEE  LIGNE\n");
+      fprintf (stderr, "   ---   ------  -----\n");
+   }
+
+   // Faire l'analyse lexical et syntaxique du fichier a compiler
+   if ( yyparse() || erreurs > 0 ) {
+      // retourner un code d'erreur (1)
+      fprintf (stderr, "\n*** compilation terminee sans succes ***\n\n");
+      remove ( argv[nomFichierSortie] );  // ne rien produire - minimiser les problemes
+      exit (EXIT_FAILURE);
+   }
+
+   // ajuster la longueur du fichier binaire en debut de fichier binaire
+   if ( fseek (fichierSortie, 0, SEEK_SET) == 0 ) {
+      unsigned char poidsFaible = (unsigned char) nOctets;
+      unsigned char poidsFort   = (unsigned char) (nOctets >> 8);
+      fprintf ( fichierSortie, "%c%c", poidsFort, poidsFaible );
+   }
+   else {
+      // retourner un code d'erreur (1)
+      fprintf (stderr, "\n*** incapable de determiner la longueur du fichier binaire ***\n\n");
+      remove ( argv[nomFichierSortie] );
+      exit (EXIT_FAILURE);
+   }
+
+   // Donner le compte du nombre d'octets dans le fichier binaire
+   if ( verbose > 0 ) {
+      fprintf (stderr, "\n   Nombre d'octets dans le fichier binaire produit: %d\n\n", nOctets);
+   }
+
+   // retourner le code unix standard pour un succes (utile pour
+   // usage dans un Makefile par exemple)
+   exit (EXIT_SUCCESS);
+}
+
+
diff --git a/tp/tp9/write_byte_code/progmem/progmem.yy.c b/tp/tp9/write_byte_code/progmem/progmem.yy.c
new file mode 100644
index 0000000..af01d2d
--- /dev/null
+++ b/tp/tp9/write_byte_code/progmem/progmem.yy.c
@@ -0,0 +1,1954 @@
+#line 2 "progmem.yy.c"
+
+#line 4 "progmem.yy.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 35
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! C99 */
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE yyrestart(yyin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k.
+ * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
+ * Ditto for the __ia64__ case accordingly.
+ */
+#define YY_BUF_SIZE 32768
+#else
+#define YY_BUF_SIZE 16384
+#endif /* __ia64__ */
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int yyleng;
+
+extern FILE *yyin, *yyout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via yyrestart()), so that the user can continue scanning by
+	 * just pointing yyin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when yytext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int yyleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow yywrap()'s to do buffer switches
+ * instead of setting up a fresh yyin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void yyrestart (FILE *input_file  );
+void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
+void yy_delete_buffer (YY_BUFFER_STATE b  );
+void yy_flush_buffer (YY_BUFFER_STATE b  );
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void yypop_buffer_state (void );
+
+static void yyensure_buffer_stack (void );
+static void yy_load_buffer_state (void );
+static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,int len  );
+
+void *yyalloc (yy_size_t  );
+void *yyrealloc (void *,yy_size_t  );
+void yyfree (void *  );
+
+#define yy_new_buffer yy_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+
+typedef unsigned char YY_CHAR;
+
+FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int yylineno;
+
+int yylineno = 1;
+
+extern char *yytext;
+#define yytext_ptr yytext
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up yytext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	yyleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 25
+#define YY_END_OF_BUFFER 26
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[70] =
+    {   0,
+        0,    0,   26,   24,    1,    2,    3,    5,    6,   24,
+       21,   22,   23,   23,   23,   23,   23,   23,   23,   23,
+       23,   23,   23,   23,   23,    1,    5,    6,    4,   21,
+       23,   23,   23,   23,   23,   23,   23,   23,   23,   23,
+       23,   23,   23,   23,   23,   23,   23,   23,   23,   23,
+       23,   23,   23,    4,    9,   10,   19,    7,   11,   20,
+        8,   14,   15,   16,   13,   12,   17,   18,    0
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    4,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    1,    1,    5,    1,    6,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    7,    8,    8,    8,
+        8,    8,    8,    8,    8,    8,    8,    1,    9,    1,
+        1,    1,    1,    1,   10,   11,   12,   13,   14,   15,
+       16,   17,   18,   17,   17,   19,   20,   21,   22,   17,
+       17,   23,   24,   25,   17,   26,   17,   17,   17,   17,
+        1,    1,    1,    1,    1,    1,   27,   28,   29,   30,
+
+       31,   32,   33,   17,   34,   17,   17,   35,   36,   37,
+       38,   17,   17,   39,   40,   41,   17,   42,   17,   17,
+       17,   17,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static yyconst flex_int32_t yy_meta[43] =
+    {   0,
+        1,    1,    2,    1,    1,    1,    1,    3,    1,    3,
+        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
+        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
+        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
+        3,    3
+    } ;
+
+static yyconst flex_int16_t yy_base[74] =
+    {   0,
+        0,    0,  105,  106,  102,  106,  106,    0,    0,   96,
+       94,  106,   76,    0,   33,   34,   36,   38,   77,   58,
+       22,   23,   28,   29,   59,   95,    0,    0,    0,   88,
+        0,   70,   75,   46,   68,   80,   70,   37,   76,   66,
+       66,   48,   46,   50,   36,   41,   50,   39,   27,   44,
+       35,   34,   40,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,  106,   77,
+       80,   65,   83
+    } ;
+
+static yyconst flex_int16_t yy_def[74] =
+    {   0,
+       69,    1,   69,   69,   69,   69,   69,   70,   71,   69,
+       72,   69,   72,   72,   72,   72,   72,   72,   72,   72,
+       72,   72,   72,   72,   72,   69,   70,   71,   73,   72,
+       72,   72,   72,   72,   72,   72,   72,   72,   72,   72,
+       72,   72,   72,   72,   72,   72,   72,   72,   72,   72,
+       72,   72,   72,   73,   72,   72,   72,   72,   72,   72,
+       72,   72,   72,   72,   72,   72,   72,   72,    0,   69,
+       69,   69,   69
+    } ;
+
+static yyconst flex_int16_t yy_nxt[149] =
+    {   0,
+        4,    5,    6,    7,    8,    9,   10,   11,   12,   13,
+       14,   14,   15,   14,   16,   14,   14,   14,   14,   17,
+       14,   14,   14,   18,   19,   14,   20,   14,   14,   21,
+       14,   22,   14,   14,   14,   23,   14,   14,   14,   24,
+       25,   14,   33,   34,   36,   38,   35,   40,   44,   45,
+       47,   37,   46,   41,   49,   51,   48,   57,   39,   62,
+       67,   52,   63,   68,   57,   62,   50,   31,   63,   67,
+       58,   66,   68,   65,   64,   61,   58,   27,   60,   27,
+       28,   59,   28,   54,   56,   54,   55,   66,   65,   64,
+       61,   60,   59,   56,   55,   30,   26,   53,   43,   42,
+
+       32,   30,   29,   26,   69,    3,   69,   69,   69,   69,
+       69,   69,   69,   69,   69,   69,   69,   69,   69,   69,
+       69,   69,   69,   69,   69,   69,   69,   69,   69,   69,
+       69,   69,   69,   69,   69,   69,   69,   69,   69,   69,
+       69,   69,   69,   69,   69,   69,   69,   69
+    } ;
+
+static yyconst flex_int16_t yy_chk[149] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,   15,   15,   16,   17,   15,   18,   21,   21,
+       22,   16,   21,   18,   23,   24,   22,   34,   17,   38,
+       42,   24,   38,   42,   45,   49,   23,   72,   49,   53,
+       34,   52,   53,   51,   50,   48,   45,   70,   47,   70,
+       71,   46,   71,   73,   44,   73,   43,   41,   40,   39,
+       37,   36,   35,   33,   32,   30,   26,   25,   20,   19,
+
+       13,   11,   10,    5,    3,   69,   69,   69,   69,   69,
+       69,   69,   69,   69,   69,   69,   69,   69,   69,   69,
+       69,   69,   69,   69,   69,   69,   69,   69,   69,   69,
+       69,   69,   69,   69,   69,   69,   69,   69,   69,   69,
+       69,   69,   69,   69,   69,   69,   69,   69
+    } ;
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+extern int yy_flex_debug;
+int yy_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *yytext;
+#line 1 "progmem.l"
+/*
+    Progmem: fichier Flex pour l'analyse lexical des instructions
+             du compilateur qui genere le bytecode pour le cours inf1995
+
+    Jerome Collin
+    Juin 2005
+*/
+#line 10 "progmem.l"
+
+#include "progmem.tab.h"
+
+int ligne = 1;
+extern void yyerror ( char const *s);
+
+#line 527 "progmem.yy.c"
+
+#define INITIAL 0
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int yylex_destroy (void );
+
+int yyget_debug (void );
+
+void yyset_debug (int debug_flag  );
+
+YY_EXTRA_TYPE yyget_extra (void );
+
+void yyset_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *yyget_in (void );
+
+void yyset_in  (FILE * in_str  );
+
+FILE *yyget_out (void );
+
+void yyset_out  (FILE * out_str  );
+
+int yyget_leng (void );
+
+char *yyget_text (void );
+
+int yyget_lineno (void );
+
+void yyset_lineno (int line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int yywrap (void );
+#else
+extern int yywrap (void );
+#endif
+#endif
+
+    static void yyunput (int c,char *buf_ptr  );
+    
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k */
+#define YY_READ_BUF_SIZE 16384
+#else
+#define YY_READ_BUF_SIZE 8192
+#endif /* __ia64__ */
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
+		{ \
+		int c = '*'; \
+		size_t n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( yyin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else \
+		{ \
+		errno=0; \
+		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(yyin); \
+			} \
+		}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int yylex (void);
+
+#define YY_DECL int yylex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after yytext and yyleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+#line 21 "progmem.l"
+
+
+#line 717 "progmem.yy.c"
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! yyin )
+			yyin = stdin;
+
+		if ( ! yyout )
+			yyout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			yyensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				yy_create_buffer(yyin,YY_BUF_SIZE );
+		}
+
+		yy_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of yytext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+yy_match:
+		do
+			{
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			if ( yy_accept[yy_current_state] )
+				{
+				(yy_last_accepting_state) = yy_current_state;
+				(yy_last_accepting_cpos) = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 70 )
+					yy_c = yy_meta[(unsigned int) yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			++yy_cp;
+			}
+		while ( yy_base[yy_current_state] != 106 );
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+		if ( yy_act == 0 )
+			{ /* have to back up */
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			yy_act = yy_accept[yy_current_state];
+			}
+
+		YY_DO_BEFORE_ACTION;
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = (yy_hold_char);
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			goto yy_find_action;
+
+case 1:
+YY_RULE_SETUP
+#line 23 "progmem.l"
+/* ignorer les espaces */
+	YY_BREAK
+case 2:
+/* rule 2 can match eol */
+YY_RULE_SETUP
+#line 24 "progmem.l"
+{ ligne++; }
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+#line 25 "progmem.l"
+/* ignorer les \r, tenir compte uniquement du /n */
+	YY_BREAK
+/* passer les lignes de commentaire */
+case 4:
+YY_RULE_SETUP
+#line 28 "progmem.l"
+
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+#line 29 "progmem.l"
+
+	YY_BREAK
+case 6:
+YY_RULE_SETUP
+#line 30 "progmem.l"
+
+	YY_BREAK
+/* reconnaitre les mots reserves */
+case 7:
+YY_RULE_SETUP
+#line 34 "progmem.l"
+{ return DBT; }
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 35 "progmem.l"
+{ return FIN; }
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+#line 36 "progmem.l"
+{ return ATT; }
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+#line 37 "progmem.l"
+{ return DAL; }
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+#line 38 "progmem.l"
+{ return DET; }
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+#line 39 "progmem.l"
+{ return SGO; }
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+#line 40 "progmem.l"
+{ return SAR; }
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+#line 41 "progmem.l"
+{ return MAR; }
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+#line 42 "progmem.l"
+{ return MAV; }
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+#line 43 "progmem.l"
+{ return MRE; }
+	YY_BREAK
+case 17:
+YY_RULE_SETUP
+#line 44 "progmem.l"
+{ return TRD; }
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+#line 45 "progmem.l"
+{ return TRG; }
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+#line 46 "progmem.l"
+{ return DBC; }
+	YY_BREAK
+case 20:
+YY_RULE_SETUP
+#line 47 "progmem.l"
+{ return FBC; }
+	YY_BREAK
+/* la donnee est toujours un entier */
+case 21:
+YY_RULE_SETUP
+#line 50 "progmem.l"
+{
+             yylval.typeString = yytext;
+             return DONNEE;
+           }
+	YY_BREAK
+case 22:
+YY_RULE_SETUP
+#line 55 "progmem.l"
+{ return POINTVIRGULE; }
+	YY_BREAK
+/* tout autre caratere est un probleme */
+case 23:
+YY_RULE_SETUP
+#line 58 "progmem.l"
+{ return MAUVAISJETON; }
+	YY_BREAK
+case 24:
+YY_RULE_SETUP
+#line 60 "progmem.l"
+{ yyerror ( "character non reconnu"); }
+	YY_BREAK
+case 25:
+YY_RULE_SETUP
+#line 62 "progmem.l"
+ECHO;
+	YY_BREAK
+#line 933 "progmem.yy.c"
+case YY_STATE_EOF(INITIAL):
+	yyterminate();
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed yyin at a new source and called
+			 * yylex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_c_buf_p);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( yywrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * yytext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of yylex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), (size_t) num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			yyrestart(yyin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		if ( yy_accept[yy_current_state] )
+			{
+			(yy_last_accepting_state) = yy_current_state;
+			(yy_last_accepting_cpos) = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 70 )
+				yy_c = yy_meta[(unsigned int) yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	register int yy_is_jam;
+    	register char *yy_cp = (yy_c_buf_p);
+
+	register YY_CHAR yy_c = 1;
+	if ( yy_accept[yy_current_state] )
+		{
+		(yy_last_accepting_state) = yy_current_state;
+		(yy_last_accepting_cpos) = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 70 )
+			yy_c = yy_meta[(unsigned int) yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 69);
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+    static void yyunput (int c, register char * yy_bp )
+{
+	register char *yy_cp;
+    
+    yy_cp = (yy_c_buf_p);
+
+	/* undo effects of setting up yytext */
+	*yy_cp = (yy_hold_char);
+
+	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		register int number_to_move = (yy_n_chars) + 2;
+		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
+					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
+		register char *source =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
+
+		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
+
+		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+	(yytext_ptr) = yy_bp;
+	(yy_hold_char) = *yy_cp;
+	(yy_c_buf_p) = yy_cp;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					yyrestart(yyin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( yywrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve yytext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void yyrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        yyensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            yy_create_buffer(yyin,YY_BUF_SIZE );
+	}
+
+	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
+	yy_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		yypop_buffer_state();
+	 *		yypush_buffer_state(new_buffer);
+     */
+	yyensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	yy_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (yywrap()) processing, but the only time this flag
+	 * is looked at is after yywrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void yy_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	yy_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with yy_create_buffer()
+ * 
+ */
+    void yy_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		yyfree((void *) b->yy_ch_buf  );
+
+	yyfree((void *) b  );
+}
+
+#ifndef __cplusplus
+extern int isatty (int );
+#endif /* __cplusplus */
+    
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a yyrestart() or at EOF.
+ */
+    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	yy_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then yy_init_buffer was _probably_
+     * called from yyrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void yy_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		yy_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	yyensure_buffer_stack();
+
+	/* This block is copied from yy_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from yy_switch_to_buffer. */
+	yy_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void yypop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	yy_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		yy_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void yyensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+								  
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	yy_switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to yylex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       yy_scan_bytes() instead.
+ */
+YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
+{
+    
+	return yy_scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
+ * scan from a @e copy of @a bytes.
+ * @param yybytes the byte buffer to scan
+ * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) yyalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = yy_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		yytext[yyleng] = (yy_hold_char); \
+		(yy_c_buf_p) = yytext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		yyleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int yyget_lineno  (void)
+{
+        
+    return yylineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *yyget_in  (void)
+{
+        return yyin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *yyget_out  (void)
+{
+        return yyout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int yyget_leng  (void)
+{
+        return yyleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *yyget_text  (void)
+{
+        return yytext;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void yyset_lineno (int  line_number )
+{
+    
+    yylineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see yy_switch_to_buffer
+ */
+void yyset_in (FILE *  in_str )
+{
+        yyin = in_str ;
+}
+
+void yyset_out (FILE *  out_str )
+{
+        yyout = out_str ;
+}
+
+int yyget_debug  (void)
+{
+        return yy_flex_debug;
+}
+
+void yyset_debug (int  bdebug )
+{
+        yy_flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from yylex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    yyin = stdin;
+    yyout = stdout;
+#else
+    yyin = (FILE *) 0;
+    yyout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * yylex_init()
+     */
+    return 0;
+}
+
+/* yylex_destroy is for both reentrant and non-reentrant scanners. */
+int yylex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		yy_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		yypop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	yyfree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * yylex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *yyalloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *yyrealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void yyfree (void * ptr )
+{
+	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+#line 62 "progmem.l"
+
+
+
+// Un seul fichier a analyser - aucun support pour un genre de fichier
+// "include" - ne rien faire
+int yywrap () {
+   return 1;
+}
+
+// Pour tout ce qui doit etre fait avant que l'analyse lexical ne debute
+// Ouvrire le fichier source pour y lire les instructions
+int prologLexical ( const char *fichier ) {
+   yyin = fopen( fichier, "r" );
+   if ( yyin == NULL ) {
+       fprintf (stderr, "Erreur: incapable d'ouvrir le fichier source %s\n",
+                                                              fichier );
+       return 0; // code d'erreur
+   }
+
+   return 1; // succes
+}
+
+
+
diff --git a/tp/tp9/write_byte_code/serieViaUSB/Makefile b/tp/tp9/write_byte_code/serieViaUSB/Makefile
new file mode 100644
index 0000000..cb19fb6
--- /dev/null
+++ b/tp/tp9/write_byte_code/serieViaUSB/Makefile
@@ -0,0 +1,28 @@
+#
+# Makefile simple pour le programme serieViaUSB
+# Quelques regles simples.
+#
+# Jerome Collin
+# Fevrier 2007
+# 
+PROG = serieViaUSB
+BINNAME = serieViaUSB
+
+CC = g++
+
+CCFLAGS = -DCPLUSPLUS -g -I . -Wall -O3 -Wformat=0
+
+OBJS = serieViaUSB.o
+LIBS = -l usb
+
+$(PROG): $(OBJS)
+	$(CC) $(OBJS) $(LIBS) -o $(BINNAME)
+
+.cc.o:
+	$(CC) $(CCFLAGS) -c $*.cc
+
+all: $(PROG)
+	
+clean:
+	rm -f $(OBJS) $(PROG) *~
+
diff --git a/tp/tp9/write_byte_code/serieViaUSB/serieViaUSB b/tp/tp9/write_byte_code/serieViaUSB/serieViaUSB
new file mode 100755
index 0000000..0038d3b
Binary files /dev/null and b/tp/tp9/write_byte_code/serieViaUSB/serieViaUSB differ
diff --git a/tp/tp9/write_byte_code/serieViaUSB/serieViaUSB.cc b/tp/tp9/write_byte_code/serieViaUSB/serieViaUSB.cc
new file mode 100644
index 0000000..3ad4cfa
--- /dev/null
+++ b/tp/tp9/write_byte_code/serieViaUSB/serieViaUSB.cc
@@ -0,0 +1,478 @@
+
+/*
+    serieViaUSB: programme qui peut etre considere comme un terminal
+                 extremement primitif et qui vise l'echange de quelques
+                 octets avec une carte a microcontroleur par port RS232
+                 Unique comminication possible : 2400 baud, 8 bits,
+                 aucun bit de parite et un seul d'arret.
+
+    Matthew Khouzam
+    Jerome Collin
+    Michaël Ferris
+    Mathieu Marengère-Gosselin
+    Fevrier 2007
+    Modifications, mars 2011
+
+*/
+
+#include <stdio.h>
+#include <limits.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <string.h>
+#include <limits>
+#include <time.h>
+#include <usb.h>        /* acces a libusb, voir http://libusb.sourceforge.net/ */
+#include <usbcmd.h>
+#include <ctype.h>
+
+enum ModesAffichage{BYTE, HEX, DEC, BIN};
+
+// vrai s'il y a communication de la carte vers le PC.
+int lecture = false;
+
+// vrai s'il y a communication du PC vers la carte.
+int ecriture = false;
+
+// mode d'affichage est à BYTE par défaut.
+ModesAffichage modeAffichage = BYTE;
+
+// Nombre de caractères avant de faire un saut
+int nbSauts = 0;
+
+// transmettre uniquement nBytes
+int nBytes = INT_MAX;
+
+FILE *fpFichier = NULL;
+char fichier[1024] = "";
+int utiliseFichier = false;
+
+// pour la conversion char-bin. 
+// Tiré de http://cboard.cprogramming.com/c-programming/42817-convert-char-binary.html
+char* charToBin ( unsigned char c )
+{
+    static char bin[CHAR_BIT + 1] = {0};
+    int i;
+
+    for ( i = CHAR_BIT - 1; i >= 0; i-- )
+    {
+        bin[i] = (c % 2) + '0';
+        c /= 2;
+    }
+
+    return bin;
+}
+
+// pour l'interface USB vers la carte
+usb_dev_handle *gestionUSB;
+
+void afficherAide ( void ) {
+   fprintf (stderr, "\n" );
+   fprintf (stderr, "usage: serieViaUSB [-l | -e] [-nb <n>] [-f <fichier>] [-h | -d | -b] [-s <n>]\n" );
+   fprintf (stderr, "\n" );
+   fprintf (stderr, "description : programme permettant de recevoir et\n" );
+   fprintf (stderr, "              d'envoyer des octets de facon serielle mais\n" );
+   fprintf (stderr, "              indirectement via le cable USB\n" );
+   fprintf (stderr, "              pour echange avec la carte microcontroleur\n" );
+   fprintf (stderr, "              du cours inf1995.  Aucun protocole\n" );
+   fprintf (stderr, "              special ne controle la signification des\n");
+   fprintf (stderr, "              octets.\n" );
+   fprintf (stderr, "\n" );
+   fprintf (stderr, "-e --ecriture: pour envoie des donnees vers la\n" );
+   fprintf (stderr, "               la carte.  Cette option demande\n" );
+   fprintf (stderr, "               l'utilisation de l'option -f.\n" );
+   fprintf (stderr, "\n" );
+   fprintf (stderr, "-l --lecture: pour reception des donnees en provenance\n" );
+   fprintf (stderr, "              de la carte\n" );
+   fprintf (stderr, "\n" );
+   fprintf (stderr, "-nb --nBytes <n>: terminer le programme directement apres\n" );
+   fprintf (stderr, "              le transfert de n octets.  Sans cette option,\n" );
+   fprintf (stderr, "              lit ou ecrit indefiniment.\n" );
+   fprintf (stderr, "\n" );
+   fprintf (stderr, "-f --fichier <fichier>:\n");
+   fprintf (stderr, "              Prendre les donnees a envoyer vers la carte\n" );
+   fprintf (stderr, "              dans le fichier specifie (implique l'option\n" );
+   fprintf (stderr, "              -e) ou ecrire les donnees dans le fichier\n" );
+   fprintf (stderr, "              lorsqu'elles proviennent de la carte\n" );
+   fprintf (stderr, "              (implique l'option -l). stdout est utilise\n" );
+   fprintf (stderr, "              avec l'option -e si l'option -f n'est pas\n" );
+   fprintf (stderr, "              utilisee (cas par defaut).\n" );
+   fprintf (stderr, "\n" );
+   fprintf (stderr, "-h --hexadecimal: afficher les octets envoyés ou reçus\n" );
+   fprintf (stderr, "                  dans une représentation hexadécimale.\n" );
+   fprintf (stderr, "\n" );
+   fprintf (stderr, "-d --decimal: afficher les octets envoyés ou reçus\n" );
+   fprintf (stderr, "                  dans une représentation décimale.\n" );
+   fprintf (stderr, "\n" );
+   fprintf (stderr, "-b --binaire: afficher les octets envoyés ou reçus\n" );
+   fprintf (stderr, "                  dans une représentation binaire.\n" );
+   fprintf (stderr, "\n" );
+   fprintf (stderr, "-s --saut <n>: effectue un retour à la ligne à chaque n\n" );
+   fprintf (stderr, "                  caractère.\n" );
+   fprintf (stderr, "\n" );
+   fflush(0);
+   exit (-1);
+}
+
+/* Fonctions pour gerer le USB */
+
+/* fonction assez standard pour l'ouverture du port USB */
+int usbOuvrir()
+{
+  struct usb_bus    *bus;
+  struct usb_device *dev = 0;
+
+  /* facon de faire standard pour trouver le device USB et l'ouvrir... */
+  usb_init();
+  usb_find_busses();
+  usb_find_devices();
+  for(bus=usb_busses; bus; bus=bus->next){
+    for(dev=bus->devices; dev; dev=dev->next){
+      if(dev->descriptor.idVendor == USBDEV_VENDOR &&
+         dev->descriptor.idProduct == USBDEV_PRODUCT)
+        break;
+    }
+    if(dev)
+      break;
+  }
+  if( ! dev ) {
+    fprintf (stderr, "Erreur: incapable de trouver le peripherique USB ");
+    fprintf (stderr, "(vendor=0x%x product=0x%x)\n", USBDEV_VENDOR, USBDEV_PRODUCT);
+    exit (-1);
+  }
+
+  // la documentation de libUSB donne des exemples de cette facon de faire
+  gestionUSB = usb_open(dev);
+  if ( ! gestionUSB ) {
+    fprintf (stderr, "Erreur: incapable d'ouvrir le port USB vers le ");
+    fprintf (stderr, "peripherique: %s\n", usb_strerror());
+    usb_close (gestionUSB);
+    exit (-1);
+  }
+
+  return 0;
+}
+
+int usbAjustementSerie (int baud, int bits, int parity)
+{
+  int nOctets;
+  unsigned char cmd[4];
+  char msg[4] = {0, 0, 0, 0};
+  // le firmware attend ces parametres, et dans cet ordre
+  cmd[0] = baud;
+  cmd[1] = bits;
+  cmd[2] = parity;
+  cmd[3] = 0;
+
+  // USBASP_FUNC_SETSERIOS ajuste les parametres USB (voir firmware)
+  nOctets = usb_control_msg (gestionUSB,
+             USB_TYPE_VENDOR | USB_RECIP_DEVICE | (1 << 7),
+             USBASP_FUNC_SETSERIOS,
+             (cmd[1] << 8) | cmd[0], (cmd[3] << 8) | cmd[2],
+             msg, 4, 5000);
+
+  if ( nOctets < 0 ) {
+     fprintf(stderr, "Erreur: probleme de transmission USB: %s\n", usb_strerror());
+     usb_close (gestionUSB);
+     exit (-1);
+  }
+
+  // la configuration se confirme par un echo des parametres
+  // il faut donc verifier que l'on a bien recu ce qu'on attend...
+  if ( msg[0] == cmd[0] && msg[1] == cmd[1] &&
+       msg[2] == cmd[2] && msg[3] == msg[3] ) {
+     return 1;
+  }
+
+  return 0;
+}
+
+int analyseLigneDeCommande ( int argc, char *argv[] ) {
+
+   // analyze de la ligne de commande
+   int i = 1;
+   while ( i < argc ) {
+      // nombre d'octets: -nb | --nBytes <int>
+      if ( strcmp (argv[i], "-nb") == 0 ||
+           strcmp (argv[i], "--nBytes") == 0 ) {
+         i++;
+         if ( i < argc ) {
+            nBytes = strtol ( argv[i], NULL, 10);
+            if ( nBytes == LONG_MIN || nBytes == LONG_MAX ) {
+               fprintf (stderr, "Erreur: nombre d'octets incorrect pour ");
+               fprintf (stderr, "l'option -nb\n\n");
+               afficherAide();
+            }
+         }
+         else {
+            fprintf (stderr, "Erreur: argument manquant pour -nb ou --nBytes\n\n");
+            afficherAide();
+         }
+      }
+      // fichier d'entree ou de sortie: -f | -fichier <string>
+      else if ( strcmp (argv[i], "-f") == 0 ||
+           strcmp (argv[i], "--fichier") == 0 ) {
+         i++;
+         utiliseFichier = true;
+         if ( i < argc && strlen( argv[i] ) < 1023 ) {
+            strcpy ( fichier, argv[i] );
+         }
+         else {
+            fprintf (stderr, "Erreur: argument manquant pour -f ou --fichier\n\n");
+            afficherAide();
+         }
+      }
+      else if ( strcmp (argv[i], "-s") == 0 ||
+           strcmp (argv[i], "--saut") == 0 ) {
+         i++;
+         if ( i < argc ) {
+            nbSauts = strtol ( argv[i], NULL, 10);
+         }
+         else {
+            fprintf (stderr, "Erreur: argument manquant pour -s ou --saut\n\n");
+            afficherAide();
+         }
+      }
+      // mode lecture: -l | --lecture
+      else if ( strcmp (argv[i], "-l") == 0 ||
+                strcmp (argv[i], "--lecture") == 0 ) {
+         lecture = true;
+      }
+      else if ( strcmp (argv[i], "-e") == 0 ||
+                strcmp (argv[i], "--ecriture") == 0 ) {
+         ecriture = true;
+      }
+      else if ( strcmp (argv[i], "-h") == 0 ||
+                strcmp (argv[i], "--hexadecimal") == 0 ) {
+         modeAffichage = HEX;
+      }
+      else if ( strcmp (argv[i], "-d") == 0 ||
+                strcmp (argv[i], "--decimal") == 0 ) {
+         modeAffichage = DEC;
+      }
+      else if ( strcmp (argv[i], "-b") == 0 ||
+                strcmp (argv[i], "--binaire") == 0 ) {
+         modeAffichage = BIN;
+      }
+      else {
+         afficherAide();
+      }
+      i++;
+   }
+
+   // determiner la lecture et/ou l'ecriture et ajuster
+   // la lecture ou l'ecriture dans le fichier en consequence au besoin
+   char modeFichier[4] = "";
+   if ( lecture == ecriture ) {
+      fprintf (stderr, "Erreur: exactement une option, -l ou -e ");
+      fprintf (stderr, "doit etre specifiee\n");
+      afficherAide();
+   }
+   else if ( lecture == true ) {
+      strcpy (modeFichier, "w");
+      fpFichier = stdout;
+   }
+   else if ( ecriture == true ) {
+      strcpy (modeFichier, "r");
+      fpFichier = stdin;
+   }
+
+   // Ouverture du fichier, si necessaire
+   if ( utiliseFichier == true ) {
+      fpFichier = fopen (fichier, modeFichier);
+      if ( fpFichier == NULL ) {
+         fprintf (stderr, "Erreur: probleme en essayant d'ouvrir le fichier" );
+         fprintf (stderr, " %s\n", fichier);
+         afficherAide();
+      }
+   }
+
+   // le cas de l'ecriture est un peu special
+   if ( ecriture == true ) {
+      // l'ecriture doit implique un fichier en entree
+      if ( utiliseFichier == false ) {
+         fprintf (stderr, "Erreur: l'utilisation de l'option -e implique\n");
+         fprintf (stderr, "        l'utilisation de l'option -f\n\n");
+         afficherAide();
+      }
+      else {
+         // on doit avoir le nombre precis d'octets a transmettre
+         // lorsqu'on ecrit vers la carte, ca simplifie la communication
+         struct stat buf;
+         if ( stat(fichier, &buf) != 0 ) {
+            fprintf (stderr, "Erreur: incapable d'optenir des informations ");
+            fprintf (stderr, "sur le fichier %s\n", fichier);
+            exit (-1);
+         }
+         if ( buf.st_size < nBytes ) {
+            nBytes = buf.st_size;
+         }
+      } 
+   }
+
+   return 1; // succes
+}
+
+int main ( int argc, char *argv[] ) {
+
+   // commencer par analyser les options sur la ligne de commande...
+   if ( ! analyseLigneDeCommande ( argc, argv ) )
+      return -1;
+
+   /* OK, ouvrir tout ce qui est USB... */
+   usbOuvrir();
+   if ( usbAjustementSerie(USBASP_MODE_SETBAUD2400,
+                           USBASP_MODE_UART8BIT, USBASP_MODE_PARITYN ) ) {
+      fprintf (stderr, "OK: le peripherique USB est reconnu et la\n");
+      fprintf (stderr, "    communication serie doit se faire a 2400 baud,\n");
+      fprintf (stderr, "    8 bits et sans parite.\n" );
+      fprintf (stderr, "--------------------------------------------\n");
+   }
+   else {
+      fprintf(stderr, "Erreur: incapable d'ajuster la communication serie\n");
+      exit (-1);
+   }
+   fflush(0);
+
+   // lecture et/ou ecriture sans fin
+   int i = 0;
+   int j = 0;
+   int k = 0;
+   int rtn;
+   int grandeurTampon = 8;
+   unsigned char tampon[grandeurTampon];
+   struct timespec tempSpec;
+   tempSpec.tv_sec = 0;
+   tempSpec.tv_nsec = 80000000; // 50 ms
+
+   while ( i < nBytes ) {
+     // mettre 0xFF dans tout le tampon
+     grandeurTampon = 8;
+     memset (tampon, 0xFF, grandeurTampon);
+
+     // lecture - le PC recoit les donnees de la carte
+     if ( lecture ) {
+        rtn = usb_control_msg (gestionUSB,
+                   USB_TYPE_VENDOR | USB_RECIP_DEVICE | (1 << 7),
+                   USBASP_FUNC_READSER,
+                   0, 0, (char *)tampon,
+                   grandeurTampon, 5000);
+        if ( rtn < 0 ){
+          fprintf (stderr, "Erreur: problem de tansmission USB:" );
+          fprintf (stderr, " %s\n", usb_strerror());
+          usb_close (gestionUSB);
+          exit(-1);
+        }
+
+        /* le premier octet donne le nombre d'octets vraiment transferes 
+           (au maximum 7) */
+        if ( tampon[0] < grandeurTampon ) {
+           grandeurTampon = tampon[0] + 1;
+        }
+
+        j = 1;
+        while ( j < grandeurTampon && i < nBytes ) {
+          switch( modeAffichage )
+          {
+              case HEX:
+                  fprintf(fpFichier, "%#04x ", tampon[j]);
+                  break;
+
+              case DEC:
+                  fprintf(fpFichier, "%#04d ", tampon[j]);
+                  break;
+
+              case BIN:
+                  fprintf(fpFichier, "%s ", charToBin(tampon[j]));
+                  break;
+
+              case BYTE:
+              default:
+                  fputc (tampon[j], fpFichier);
+          }
+        
+          if( nbSauts ) {
+              if( ( (i+1) % nbSauts) == 0 ) { fputc ('\n', fpFichier); }
+          }
+
+          i++;
+          j++;
+        }
+      }
+      // le PC envoie les donnees vers la carte
+      if ( ecriture ) {
+        // remplir le tampon - fpFichier ne peut etre stdin
+        j = 1;
+        while ( j < grandeurTampon && i < nBytes ) {
+          tampon[j] = getc (fpFichier);
+          i++;
+          j++;
+        }
+        tampon[0] = j - 1;
+
+        // on envoie vers l'USB  0 == envoie
+        rtn = usb_control_msg (gestionUSB,
+                   USB_TYPE_VENDOR | USB_RECIP_DEVICE | (0 << 7),
+                   USBASP_FUNC_WRITESER,
+                   0, 0, (char *)tampon, j, 5000);
+
+        // echo a l'ecran, pas strictement necessaire mais interessant
+        for ( k = 0; k < j; k++ )
+        {
+          switch( modeAffichage )
+          {
+              case HEX:
+                  fprintf(stderr, "%#04x ", tampon[k]);
+                  break;
+
+              case DEC:
+                  fprintf(stderr, "%#04d ", tampon[k]);
+                  break;
+
+              case BIN:
+                  fprintf(stderr, "%s ", charToBin(tampon[k]));
+                  break;
+
+              case BYTE:
+              default:
+                  fputc (tampon[k], stderr);
+           }
+
+           if( nbSauts ) {
+               if( ( (k+1) % nbSauts) == 0 ) { fputc ('\n', stderr); }
+           }
+
+        }
+
+        // il faut que la carte ecrive les octets en memoire
+        // et via l'interface serie qui est lente.  Donner une chance
+        // a la carte de realiser ses operations en lui laissant du temps.
+        // ce petit delai devrait etre suffisant pour qu'elle 
+        // "n'echappe pas des octets" en cours de route...
+        nanosleep (&tempSpec, NULL);
+
+        if ( rtn < 0 ) {
+          fprintf (stderr, "Erreur: problem de tansmission USB:" );
+          fprintf (stderr, " %s\n", usb_strerror());
+          usb_close (gestionUSB);
+          exit(-1);
+        }
+      } /* while */
+
+      fflush(0);
+   }
+
+   // rapport indiquant que la transmission est terminee
+   fprintf (stderr, "\n--------------------------------------------\n");
+   fprintf (stderr, "serieViaUSB : %d octets ont ete transmis ", nBytes );
+   fprintf (stderr, "ou recus\n" );
+   fflush(0);
+
+   usb_close (gestionUSB);
+   return 0;
+}
+
+
+
diff --git a/tp/tp9/write_byte_code/serieViaUSB/usbcmd.h b/tp/tp9/write_byte_code/serieViaUSB/usbcmd.h
new file mode 100644
index 0000000..f46e890
--- /dev/null
+++ b/tp/tp9/write_byte_code/serieViaUSB/usbcmd.h
@@ -0,0 +1,60 @@
+#ifndef _USBCMD_H_
+#define _USBCMD_H_
+
+/*
+ * Commandes USB 
+ * 
+ * Par Matthew Khouzam et Jerome Collin <jerome.collin@polymtl.ca>
+ *
+ */
+#define	USBDEV_VENDOR	0x16C0	/* ATMEL */
+#define	USBDEV_PRODUCT	0x05DC 	/* USBasp */
+
+/* 
+    USB function call identifiers 
+    ATTENTION: ces identificateurs doivent etre identiques a ceux
+    contenus dans usbasp, fichier usbasp.h.
+*/
+#define USBASP_FUNC_CONNECT     1
+#define USBASP_FUNC_DISCONNECT  2
+#define USBASP_FUNC_TRANSMIT    3
+#define USBASP_FUNC_READFLASH   4
+#define USBASP_FUNC_ENABLEPROG  5
+#define USBASP_FUNC_WRITEFLASH  6
+#define USBASP_FUNC_READEEPROM  7
+#define USBASP_FUNC_WRITEEEPROM 8
+#define USBASP_FUNC_SETLONGADDRESS 9
+#define USBASP_FUNC_SETISPSCK  10
+#define USBASP_FUNC_SETSERIOS  11
+#define USBASP_FUNC_READSER    12
+#define USBASP_FUNC_WRITESER   13
+
+// Fonction ISP - USB
+#define USBASP_BLOCKFLAG_FIRST    1
+#define USBASP_BLOCKFLAG_LAST     2
+
+#define USBASP_READBLOCKSIZE   200
+#define USBASP_WRITEBLOCKSIZE  200
+
+// Fonction UART IOS
+#define USBASP_MODE_SETBAUD300		0x10
+#define USBASP_MODE_SETBAUD600		0x11
+#define USBASP_MODE_SETBAUD1200    	0x12
+#define USBASP_MODE_SETBAUD2400     0x13
+#define USBASP_MODE_SETBAUD4800     0x14
+#define USBASP_MODE_SETBAUD9600     0x15
+#define USBASP_MODE_SETBAUD19200    0x16
+#define USBASP_MODE_SETBAUD38400    0x17
+#define USBASP_MODE_SETBAUD57600    0x18
+#define USBASP_MODE_SETBAUD115200   0x19
+
+#define USBASP_MODE_UART5BIT		0x05
+#define USBASP_MODE_UART6BIT		0x06
+#define USBASP_MODE_UART7BIT		0x07
+#define USBASP_MODE_UART8BIT		0x08
+
+#define USBASP_MODE_PARITYN			0x01
+#define USBASP_MODE_PARITYE			0x02
+#define USBASP_MODE_PARITYO			0x03
+
+#endif /* _USBCMD_H_ */
diff --git a/tp/tp9/write_byte_code/sortie b/tp/tp9/write_byte_code/sortie
new file mode 100644
index 0000000..0806595
Binary files /dev/null and b/tp/tp9/write_byte_code/sortie differ
